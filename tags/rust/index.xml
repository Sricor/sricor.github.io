<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Rust on Paper</title><link>https://sricor.github.io/tags/rust/</link><description>Recent content in Rust on Paper</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 13 Dec 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://sricor.github.io/tags/rust/index.xml" rel="self" type="application/rss+xml"/><item><title>Rust Fearless Concurrency</title><link>https://sricor.github.io/posts/public/rust/fearless-concurrency/</link><pubDate>Wed, 13 Dec 2023 00:00:00 +0000</pubDate><guid>https://sricor.github.io/posts/public/rust/fearless-concurrency/</guid><description>Call the std::thread::spawn function and pass it a closure to Create a new thread. All spawned threads are shut down, when the main thread completes. Call the join method on it, will wait for its thread to finish. std::mpsc::channel function returns a tuple, the first element of which is the transmitter and the second element is the receiver. Transmitter send method takes ownership of its parameter. Receiver recv method will block the main thread’s execution and wait until a value is sent down the channel.</description></item><item><title>Rust Smart Pointers</title><link>https://sricor.github.io/posts/public/rust/smart-pointers/</link><pubDate>Tue, 12 Dec 2023 00:00:00 +0000</pubDate><guid>https://sricor.github.io/posts/public/rust/smart-pointers/</guid><description>Box&amp;lt;T&amp;gt; have single owners Box&amp;lt;T&amp;gt; allow to store data on the heap. Box&amp;lt;T&amp;gt; is a pointer, point to data on the heap. When a box goes out of scope, it will be deallocated (both for the heap and stack). Implementing the Deref trait allows to customize the behavior of the dereference operator *. Implementing the Drop trait, Rust automatically called drop when instances went out of scope. Not allowed to explicitly call drop.</description></item><item><title>Rust Ownership - Reference and Borrowing</title><link>https://sricor.github.io/posts/public/rust/ownership-reference-borrowing/</link><pubDate>Mon, 11 Dec 2023 00:00:00 +0000</pubDate><guid>https://sricor.github.io/posts/public/rust/ownership-reference-borrowing/</guid><description>引用与借用 引用允许使用值但不获取其所有权 the ownership system that makes sure references are always valid 引用的作用域是从声明的地方开始一直持续到最后一次使用为止 引用默认不允许修改引用的值，可使用 mut 关键字使其为可变引用 在任意给定时间，要么只能有一个可变引用，要么只能有多个不可变引用 引用 引用（reference）是一个地址，我们可以由此访问储存于该地址的属于其变量的数据，创建一个引用的行为称为借用（borrowing）。
fn main() { let s1 = String::from(&amp;#34;hello&amp;#34;); let len = calculate_length(&amp;amp;s1); println!(&amp;#34;The length of &amp;#39;{}&amp;#39; is {}.&amp;#34;, s1, len); } fn calculate_length(s: &amp;amp;String) -&amp;gt; usize { // s 是 String 的引用 s.len() } // 这里，s 离开了作用域。但因为它并不拥有引用值的所有权，所以什么也不会发生 calculate_length 函数以一个对象的引用作为参数而不是获取值的所有权。 &amp;amp;s1 语法让我们创建一个 指向 值 s1 的引用，但是并不拥有它，所以当引用停止使用时，它所指向的值也不会被丢弃。
可变引用 可变引用允许修改一个借用的值。
fn main() { let mut s = String::from(&amp;#34;hello&amp;#34;); change(&amp;amp;mut s); } fn change(some_string: &amp;amp;mut String) { some_string.</description></item><item><title>Rust Ownership - Scope</title><link>https://sricor.github.io/posts/public/rust/ownership-scope/</link><pubDate>Sun, 10 Dec 2023 00:00:00 +0000</pubDate><guid>https://sricor.github.io/posts/public/rust/ownership-scope/</guid><description>变量的作用域 作用域是一个项在程序中有效的范围。
{ // s 在这里无效，它尚未声明 let s = &amp;#34;hello&amp;#34;; // 从此处起，s 是有效的 ... } // 此作用域已结束，s 不再有效 变量 s 绑定到了一个字符串字面值，这个字符串值是硬编码进程序代码中的。
这里有两个重要的时间点：
当 s 进入作用域 时，它就是有效的。 这一直持续到它 离开作用域 为止。 引用的作用域 引用的作用域是从声明的地方开始一直持续到最后一次使用为止</description></item><item><title>Rust Ownership</title><link>https://sricor.github.io/posts/public/rust/ownership/</link><pubDate>Sat, 09 Dec 2023 00:00:00 +0000</pubDate><guid>https://sricor.github.io/posts/public/rust/ownership/</guid><description>所有权 每一个值都有一个所有者 At any given time, you can have either (but not both) one mutable reference or any number of immutable references. References must always be valid. 将值赋给另一个变量（包含函数实参）时移动它 当持有堆中数据值的变量离开作用域时，其值将通过 drop 被清理掉，除非数据被移动为另一个变量所有 所有权与函数 fn main() { let s = String::from(&amp;#34;hello&amp;#34;); // s 进入作用域 takes_ownership(s); // s 的值移动到函数里 ... // ... 所以到这里不再有效 let x = 5; // x 进入作用域 makes_copy(x); // x 应该移动函数里， // 但 i32 是 Copy 的， // 所以在后面可继续使用 x } // 这里，x 先移出了作用域，然后是 s。但因为 s 的值已被移走，所以不会发生改变 fn takes_ownership(some_string: String) { // some_string 进入作用域 println!</description></item></channel></rss>