<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Paper</title><link>/posts/</link><description>Recent content in Posts on Paper</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Mon, 01 Apr 2024 00:00:00 +0000</lastBuildDate><atom:link href="/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Ethereum Account</title><link>/posts/public/crypto/ethereum-account/</link><pubDate>Mon, 01 Apr 2024 00:00:00 +0000</pubDate><guid>/posts/public/crypto/ethereum-account/</guid><description>&lt;h1 id="ethereum-account">Ethereum Account&lt;/h1>
&lt;h2 id="account-types">ACCOUNT TYPES&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>Externally-owned account (EOA)&lt;/strong> – controlled by anyone with the private keys&lt;/li>
&lt;li>&lt;strong>Contract account&lt;/strong> – a smart contract deployed to the network, controlled by code.&lt;/li>
&lt;/ul>
&lt;p>Both account types have the ability to:&lt;/p>
&lt;ul>
&lt;li>Receive, hold and send ETH and tokens&lt;/li>
&lt;li>Interact with deployed smart contracts&lt;/li>
&lt;/ul>
&lt;h3 id="key-differences">Key differences&lt;/h3>
&lt;p>&lt;strong>Externally-owned&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Creating an account costs nothing&lt;/li>
&lt;li>Can initiate transactions&lt;/li>
&lt;li>Transactions between externally-owned accounts can only be ETH/token transfers&lt;/li>
&lt;li>Made up of a cryptographic pair of keys: public and private keys that control account activities&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Contract&lt;/strong>&lt;/p></description></item><item><title>Crypto Consensus</title><link>/posts/public/crypto/crypto-consensus-decision-making/</link><pubDate>Wed, 20 Dec 2023 00:00:00 +0000</pubDate><guid>/posts/public/crypto/crypto-consensus-decision-making/</guid><description>&lt;h3 id="1-共识机制类型">1. 共识机制类型&lt;/h3>
&lt;h5 id="11-工作量证明proof-of-work-pow">1.1 工作量证明（Proof-of-Work, PoW）&lt;/h5>
&lt;p>工作量证明 （Proof-of-Work, PoW）是最传统的区块链共识机制，以工作成果来证明完成的工作量。在区块链中矿工们需透过大量的电脑运算、时间及电力解开数学难题借此产生新的区块获得相对应的报酬，因此 PoW 挖矿方式也可被称为「算力挖矿」，在区块链采用 PoW 的共识机制中，比特币（Bitcoin, BTC）是其中最具有代表性的。&lt;/p>
&lt;h5 id="12-权益证明-proof-of-stake-pos">1.2 权益证明 （Proof-of-Stake, PoS）&lt;/h5>
&lt;p>权益证明 （Proof-of-Stake, PoS）亦可称为持有量证明，在此共识机制中参与挖矿的人需要将加密货币抵押在智能合约中，币龄（币龄=持币数量*持有时间）越大代表着权益越大，而权益越大的人（节点）拥有越大机会负责产生新区块，也就是说能够预期是由谁产生下一个区块，在此共识机制中的挖矿行为又可称为「持币挖矿」，目前以太坊预计于 2023 年完成以太坊 2.0 的升级，升级完成将全面采用 PoS 进行运作。&lt;/p>
&lt;h5 id="13-代理权益证明delegated-proof-of-stake-dpos">1.3 代理权益证明（Delegated Proof-of-Stake, DPoS）&lt;/h5>
&lt;p>持币者进行投票（Voting）选出一定数量的见证人（Witnesses）和票选代表人（Delegates），由见证人负责进行交易验证、记帐和产生新的区块，任务完成后即可获得相对应的报酬，因此见证人也可被称为节点或是理解为矿工，而 DPoS 的挖矿亦可被称为「投票挖矿」；而票选代表人主要负责监督区块链中的协定和效能，不参与验证和产生新的区块。投票过程在 DPoS 是持续存在的过程因此当见证人执行工作效率不好或是用户提出更诱人的平台分润机制票选代表人就有可能被替换， DPoS 可以说是以民主方式治理区块链，目前采用 DPoS 的有柚子币（EOS），该平台设立有 21 位见证人。&lt;/p>
&lt;h3 id="2-powpos-及-dpos-分析比较">2. Pow、Pos 及 DPoS 分析比较&lt;/h3>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th style="text-align: left">共识机制&lt;/th>
 &lt;th style="text-align: left">工作量证明（PoW）&lt;/th>
 &lt;th style="text-align: left">权益证明（PoS）&lt;/th>
 &lt;th style="text-align: left">代理权益证明（DPoS）&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td style="text-align: left">挖矿简介&lt;/td>
 &lt;td style="text-align: left">算力挖矿，越快解出数学题的矿工产生出新的交易区块并获得相对应的报酬&lt;/td>
 &lt;td style="text-align: left">持币挖矿，拥有币龄越高的使用者越有机会产生新的区块并获得报酬&lt;/td>
 &lt;td style="text-align: left">投票挖矿，由持有加密货币的使用者进行投票产生见证人，由见证人负责验证交易和产生新的区块&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">能源消耗&lt;/td>
 &lt;td style="text-align: left">极高&lt;/td>
 &lt;td style="text-align: left">低&lt;/td>
 &lt;td style="text-align: left">低&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">硬件设备&lt;/td>
 &lt;td style="text-align: left">需要&lt;/td>
 &lt;td style="text-align: left">不需要&lt;/td>
 &lt;td style="text-align: left">不需要&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">优点&lt;/td>
 &lt;td style="text-align: left">1. 去中心化程度高，任何人都可以自由进出节点 &lt;!-- raw HTML omitted -->2. 安全性高，破坏系统需要消耗大量成本&lt;/td>
 &lt;td style="text-align: left">1. 挖矿不需要建造昂贵的设备 &lt;!-- raw HTML omitted -->2. 降低 51% 算力攻击几率&lt;/td>
 &lt;td style="text-align: left">1. 挖矿不需要建造昂贵的设备 &lt;!-- raw HTML omitted -->2. 网络运行成本最低 &lt;!-- raw HTML omitted -->3. 节点少资源占用少，因此交易速度更快（1~10秒产生一个新区块）&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">缺点&lt;/td>
 &lt;td style="text-align: left">1. 参与挖矿需要建造昂贵的设备，可能导致挖矿集中化 &lt;!-- raw HTML omitted -->2. 挖矿过程能源损耗高 &lt;!-- raw HTML omitted -->3. 可能遭受 51% 算力攻击&lt;/td>
 &lt;td style="text-align: left">1. 流动性差（屯币者及富者越富的风险） &lt;!-- raw HTML omitted -->2. 存在权益粉碎攻击&lt;/td>
 &lt;td style="text-align: left">1. 可能遭受 51% 算力攻击 &lt;!-- raw HTML omitted -->2. 违反中心化理念，权力集中 &lt;!-- raw HTML omitted -->3. 投票意愿低 &lt;!-- raw HTML omitted -->4. 富者囤积货币取得运营主导权&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">应用实例&lt;/td>
 &lt;td style="text-align: left">比特币、以太坊 1.0&lt;/td>
 &lt;td style="text-align: left">以太坊 2.0&lt;/td>
 &lt;td style="text-align: left">EOS&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>51%攻击：单一组织或个人占有全网 51%的算力、货币…等，阻挡其他参与者加入挖矿行列，风险程度亦受到区块链大小而不同，规模越大的链越不容易受到 51%攻击。&lt;/p></description></item><item><title>Crypto Decentralized Finance</title><link>/posts/public/crypto/crypto-decentralized-finance/</link><pubDate>Wed, 20 Dec 2023 00:00:00 +0000</pubDate><guid>/posts/public/crypto/crypto-decentralized-finance/</guid><description>&lt;blockquote>
&lt;p>以下信息整理至 2023/12/20&lt;/p>
&lt;/blockquote>
&lt;h3 id="1-defi-概念">1. DeFi 概念&lt;/h3>
&lt;p>去中心化金融（Decentralized Finance, DeFi），泛指基于区块链技术架构下在智能合约平台上所衍生的加密货币及其相关的金融交易，包含借贷、保险、期货及投资理财等。&lt;/p>
&lt;p>自加密货币问世以来对于科技界及传统金融产业界掀起爆发性的革命，随着时间的演进去中心化金融的发展也日新月异，与 DeFi 相左的即为传统的「中心化金融」，传统的金融交易都需要透过「中介者（Intermediate）」来完成，使用者透过与中介者建立信任关系与熟识者或素未谋面的人完成交易，而中介者可以泛指银行、证券交易所、信用卡机构等，然而中心化金融架构下有几个显著缺点一直为人所诟病，包含有：高额且多重的交易手续费、交易时间和地点限制、低效率的结算服务、中介者甚至拥有否决交易的权力等。&lt;/p>
&lt;p>而 DeFi 顾名思义就是在所有的金融交易过程中去除「中介者」的角色，所有的交易依赖智能合约所载明的执行条件来判断交易成立与否，区块链的核心为透明化及分散性因此也可将 DeFi 称为「分散式金融」或者「开放金融」。而网络的世界无远佛届且交易无时无刻在执行使得 DeFi 具备有无地域、无时间限制且交易更为透明化，更因为交易成立与否全依赖智能合约判断直接且快速地达成普惠金融的概念，翻转理财致富只属于富者的偏见，目前 DeFi 在借贷、交易、衍生品、稳定币、保险等方面都有成熟的项目。&lt;/p>
&lt;h3 id="2-交易所">2. 交易所&lt;/h3>
&lt;p>大部分的投资人在 DeFi 的交易都会透过交易所来进行，交易所提供许多金融商品交易服务给投资人做选择在 DeFi 中交易所提供的服务包含有：加密货币兑换（购买）、现货交易、期货交易、保险等。目前在 DeFi 中有「中心化交易所（Centralized Exchange，简称：CEX）」和「去中心化交易所（Decentralized Exchange，简称 DEX）」两种。下列简单说明两者的特点：&lt;/p>
&lt;ol>
&lt;li>中心化交易所（CEX）：和传统金融交易所相似，用户需开立帐户进行注册并进行实名认证（Know Your Customer, KYC）待身份认证完成后才可开启金融活动，交易所主要代为托管用户资产，但用户没有私钥和资产的实际控制权，目前 CEX 还是 DeFi 交易的主流， CEX 大多具有方便使用的特性，许多初阶 DeFi 投资者会选择 CEX 开始活动，选用CEX 还有一个隐藏的保险机制，用户讯息由交易所托管因此在忘记密码时，可以向交易所取得密码，避免因一时疏忽而导致资产减损。&lt;/li>
&lt;li>去中心化交易所（DEX）：以区块链为概念进行设计并以智能合约自动化履行交易，允许跨钱包及跨链交易，不会将用户的资料储存在伺服器上。&lt;/li>
&lt;/ol>
&lt;h3 id="3-加密货币钱包cryptocurrency-wallet">3. 加密货币钱包（Cryptocurrency Wallet）&lt;/h3>
&lt;p>目前 DeFi 中所使用的加密货币钱包可区分为两种型态分别是热钱包（Hot wallet）及冷钱包（Cold Wallet）：&lt;/p>
&lt;ol>
&lt;li>热钱包 （Hot wallet）：主动连接至网络的加密货币钱包，加密货币及钱包都托管在交易所或专门的托管商手中，因此私钥有外流的可能性，也因为与网络连接若遭遇骇客攻击可能就会产生损失，但热钱包容易上手适合初学者或是没有巨额加密货币资产配置的人使用，一般常见的热钱包包含有交易所钱包、桌面式钱包、行动式钱包。&lt;/li>
&lt;li>冷钱包 （Cold wallet）：没有与网络有直接的连接，私钥由钱包所有人保管，若使用得当遭受骇客攻击和窃取的可能性相当低，因此安全性较热钱包来的高适合有高额加密货币配置的投资人用来保管资产，私钥由钱包所有人全权管辖若不慎遗失私钥，则所有的加密货币资产也随之不翼而飞，目前常见的冷钱包有两种，分别是硬体钱包和纸钱包。&lt;/li>
&lt;/ol>
&lt;h3 id="4-defi-投资理财类型">4. DeFi 投资理财类型&lt;/h3>
&lt;p>参与 DeFi 的投资活动最简单的方式就是购买加密货币，并将加密货币视为「股票」等待价值提升。&lt;/p>
&lt;h5 id="41-稳定币投资">4.1 稳定币投资&lt;/h5>
&lt;p>稳定币（Stablecoin）为加密货币的一种，仿效法定货币的发行藉由与某种稳定资产挂钩，使其价值维持在一定范围内，可以说是法币与加密货币的综合体，保有了两方的特性，与加密货币相比普遍来说稳定币的波动较一般加密货币来的低。根据抵押的资产可分为四个类别：&lt;/p></description></item><item><title>Rust Fearless Concurrency</title><link>/posts/public/rust/fearless-concurrency/</link><pubDate>Wed, 13 Dec 2023 00:00:00 +0000</pubDate><guid>/posts/public/rust/fearless-concurrency/</guid><description>&lt;blockquote>
&lt;ul>
&lt;li>Call the &lt;code>std::thread::spawn&lt;/code> function and pass it a closure to Create a new thread.&lt;/li>
&lt;li>All spawned threads are shut down, when the main thread completes.&lt;/li>
&lt;li>Call the &lt;code>join&lt;/code> method on it, will wait for its thread to finish.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;blockquote>
&lt;ul>
&lt;li>&lt;code>std::mpsc::channel&lt;/code> function returns a tuple, the first element of which is the transmitter and the second element is the receiver.&lt;/li>
&lt;li>Transmitter &lt;code>send&lt;/code> method takes ownership of its parameter.&lt;/li>
&lt;li>Receiver &lt;code>recv&lt;/code> method will block the main thread’s execution and wait until a value is sent down the channel.&lt;/li>
&lt;li>Receiver &lt;code>try_recv&lt;/code> method doesn’t block, but will instead return a &lt;code>Result&amp;lt;T, E&amp;gt;&lt;/code> immediately.&lt;/li>
&lt;li>Receiver can be used as an iterator.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;blockquote>
&lt;ul>
&lt;li>&lt;code>Mutex&amp;lt;T&amp;gt;&lt;/code> is a smart pointer.&lt;/li>
&lt;li>&lt;code>Mutex&amp;lt;T&amp;gt;&lt;/code> provides interior mutability&lt;/li>
&lt;li>&lt;code>Arc&amp;lt;T&amp;gt;&lt;/code> is a type like &lt;code>Rc&amp;lt;T&amp;gt;&lt;/code> that is safe to use in concurrent situations.&lt;/li>
&lt;li>Call to &lt;code>lock&lt;/code> returns a smart pointer called &lt;code>MutexGuard&lt;/code>.&lt;/li>
&lt;li>The lock will automatically be released when a &lt;code>MutexGuard&lt;/code> goes out of scope.&lt;/li>
&lt;li>Thread safety comes with a performance penalty.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="1-using-threads-to-run-code-simultaneouslyhttpsdocrust-langorgstablebookch16-01-threadshtml">&lt;a href="https://doc.rust-lang.org/stable/book/ch16-01-threads.html">1. Using Threads to Run Code Simultaneously&lt;/a>&lt;/h3>
&lt;p>In most current operating systems, an executed program’s code is run in a &lt;em>process&lt;/em>, and the operating system will manage multiple processes at once. Within a program, you can also have independent parts that run simultaneously. The features that run these independent parts are called &lt;em>threads&lt;/em>.&lt;/p></description></item><item><title>Rust Smart Pointers</title><link>/posts/public/rust/smart-pointers/</link><pubDate>Tue, 12 Dec 2023 00:00:00 +0000</pubDate><guid>/posts/public/rust/smart-pointers/</guid><description>&lt;blockquote>
&lt;ul>
&lt;li>&lt;code>Box&amp;lt;T&amp;gt;&lt;/code> have single owners&lt;/li>
&lt;li>&lt;code>Box&amp;lt;T&amp;gt;&lt;/code> allow to store data on the heap.&lt;/li>
&lt;li>&lt;code>Box&amp;lt;T&amp;gt;&lt;/code> is a pointer, point to data on the heap.&lt;/li>
&lt;li>When a box goes out of scope, it will be deallocated (both for the heap and stack).&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;blockquote>
&lt;ul>
&lt;li>Implementing the &lt;code>Deref&lt;/code> trait allows to customize the behavior of the dereference operator &lt;code>*&lt;/code>.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;blockquote>
&lt;ul>
&lt;li>Implementing the &lt;code>Drop&lt;/code> trait, Rust automatically called &lt;code>drop&lt;/code> when instances went out of scope.&lt;/li>
&lt;li>Not allowed to explicitly call &lt;code>drop&lt;/code>.&lt;/li>
&lt;li>Can drop a value early with &lt;code>std::mem::drop&lt;/code>.&lt;/li>
&lt;li>Variables are dropped in the reverse order of their creation.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;blockquote>
&lt;ul>
&lt;li>&lt;code>Rc&amp;lt;T&amp;gt;&lt;/code> allows a single value to have multiple owners.&lt;/li>
&lt;li>&lt;code>Rc&amp;lt;T&amp;gt;&lt;/code> allows only immutable borrows checked at compile time.&lt;/li>
&lt;li>&lt;code>Rc&amp;lt;T&amp;gt;&lt;/code> only gives immutable access to that data.&lt;/li>
&lt;li>&lt;code>Rc&amp;lt;T&amp;gt;&lt;/code> only for use in single-threaded scenarios.&lt;/li>
&lt;li>&lt;code>Rc::clone&lt;/code> does not make a deep copy, it does not take much time.&lt;/li>
&lt;li>&lt;code>Drop&lt;/code> trait decreases the reference count automatically when an &lt;code>Rc&amp;lt;T&amp;gt;&lt;/code> value goes out of scope&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;blockquote>
&lt;ul>
&lt;li>&lt;code>RefCell&amp;lt;T&amp;gt;&lt;/code> have single owners.&lt;/li>
&lt;li>&lt;code>RefCell&amp;lt;T&amp;gt;&lt;/code> allows immutable or mutable borrows checked at runtime.&lt;/li>
&lt;li>&lt;code>RefCell&amp;lt;T&amp;gt;&lt;/code> will panic at runtime when try to violate borrow rules.&lt;/li>
&lt;li>&lt;code>RefCell&amp;lt;T&amp;gt;&lt;/code> only for use in single-threaded scenarios.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="1-using-boxt-to-point-to-data-on-the-heaphttpsdocrust-langorgstablebookch15-01-boxhtml">&lt;a href="https://doc.rust-lang.org/stable/book/ch15-01-box.html">1. Using Box&lt;!-- raw HTML omitted --> to Point to Data on the Heap&lt;/a>&lt;/h3>
&lt;p>Boxes allow to store data on the heap rather than the stack.&lt;/p></description></item><item><title>Rust Ownership - Reference and Borrowing</title><link>/posts/public/rust/ownership-reference-borrowing/</link><pubDate>Mon, 11 Dec 2023 00:00:00 +0000</pubDate><guid>/posts/public/rust/ownership-reference-borrowing/</guid><description>&lt;h3 id="引用与借用">引用与借用&lt;/h3>
&lt;blockquote>
&lt;ul>
&lt;li>引用允许使用值但不获取其所有权&lt;/li>
&lt;li>the ownership system that makes sure references are always valid&lt;/li>
&lt;li>引用的作用域是从声明的地方开始一直持续到最后一次使用为止&lt;/li>
&lt;li>引用默认不允许修改引用的值，可使用 &lt;code>mut&lt;/code> 关键字使其为可变引用&lt;/li>
&lt;li>在任意给定时间，要么只能有一个可变引用，要么只能有多个不可变引用&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h4 id="引用">引用&lt;/h4>
&lt;p>&lt;strong>引用&lt;/strong>（&lt;em>reference&lt;/em>）是一个地址，我们可以由此访问储存于该地址的属于其变量的数据，创建一个引用的行为称为&lt;strong>借用&lt;/strong>（&lt;em>borrowing&lt;/em>）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> s1 &lt;span style="color:#f92672">=&lt;/span> String::from(&lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> len &lt;span style="color:#f92672">=&lt;/span> calculate_length(&lt;span style="color:#f92672">&amp;amp;&lt;/span>s1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;The length of &amp;#39;&lt;/span>&lt;span style="color:#e6db74">{}&lt;/span>&lt;span style="color:#e6db74">&amp;#39; is &lt;/span>&lt;span style="color:#e6db74">{}&lt;/span>&lt;span style="color:#e6db74">.&amp;#34;&lt;/span>, s1, len);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">calculate_length&lt;/span>(s: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>String) -&amp;gt; &lt;span style="color:#66d9ef">usize&lt;/span> { &lt;span style="color:#75715e">// s 是 String 的引用
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> s.len()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#75715e">// 这里，s 离开了作用域。但因为它并不拥有引用值的所有权，所以什么也不会发生
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>calculate_length&lt;/code> 函数以一个对象的引用作为参数而不是获取值的所有权。
&lt;code>&amp;amp;s1&lt;/code> 语法让我们创建一个 &lt;strong>指向&lt;/strong> 值 &lt;code>s1&lt;/code> 的引用，但是并不拥有它，所以当引用停止使用时，它所指向的值也不会被丢弃。&lt;/p>
&lt;h4 id="可变引用">可变引用&lt;/h4>
&lt;p>可变引用允许修改一个借用的值。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> s &lt;span style="color:#f92672">=&lt;/span> String::from(&lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> change(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> s);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">change&lt;/span>(some_string: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">mut&lt;/span> String) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> some_string.push_str(&lt;span style="color:#e6db74">&amp;#34;, world!&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>在任意给定时间，同一作用域内，要么只能有一个可变引用，要么只能有多个不可变引用&lt;/strong>，这一限制防止同一时间对同一数据存在多个可变引用，在编译时就避免数据竞争。&lt;/p></description></item><item><title>Rust Ownership - Scope</title><link>/posts/public/rust/ownership-scope/</link><pubDate>Sun, 10 Dec 2023 00:00:00 +0000</pubDate><guid>/posts/public/rust/ownership-scope/</guid><description>&lt;h3 id="变量的作用域">变量的作用域&lt;/h3>
&lt;p>作用域是一个项在程序中有效的范围。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>{ &lt;span style="color:#75715e">// s 在这里无效，它尚未声明
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#66d9ef">let&lt;/span> s &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>; &lt;span style="color:#75715e">// 从此处起，s 是有效的
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">..&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#75715e">// 此作用域已结束，s 不再有效
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>变量 &lt;code>s&lt;/code> 绑定到了一个字符串字面值，这个字符串值是硬编码进程序代码中的。&lt;/p>
&lt;p>这里有两个重要的时间点：&lt;/p>
&lt;ul>
&lt;li>当 &lt;code>s&lt;/code> &lt;strong>进入作用域&lt;/strong> 时，它就是有效的。&lt;/li>
&lt;li>这一直持续到它 &lt;strong>离开作用域&lt;/strong> 为止。&lt;/li>
&lt;/ul>
&lt;h3 id="引用的作用域">引用的作用域&lt;/h3>
&lt;p>引用的作用域是从声明的地方开始一直持续到最后一次使用为止&lt;/p></description></item><item><title>Rust Ownership</title><link>/posts/public/rust/ownership/</link><pubDate>Sat, 09 Dec 2023 00:00:00 +0000</pubDate><guid>/posts/public/rust/ownership/</guid><description>&lt;h3 id="所有权">所有权&lt;/h3>
&lt;blockquote>
&lt;ul>
&lt;li>每一个值都有一个&lt;strong>所有者&lt;/strong>&lt;/li>
&lt;li>At any given time, you can have &lt;em>either&lt;/em> (but not both) one mutable reference or any number of immutable references.&lt;/li>
&lt;li>References must always be valid.&lt;/li>
&lt;li>将值赋给另一个变量（包含函数实参）时移动它&lt;/li>
&lt;li>当持有堆中数据值的变量离开作用域时，其值将通过 &lt;code>drop&lt;/code> 被清理掉，除非数据被移动为另一个变量所有&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h4 id="所有权与函数">所有权与函数&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> s &lt;span style="color:#f92672">=&lt;/span> String::from(&lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>); &lt;span style="color:#75715e">// s 进入作用域
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> takes_ownership(s); &lt;span style="color:#75715e">// s 的值移动到函数里 ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// ... 所以到这里不再有效
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>; &lt;span style="color:#75715e">// x 进入作用域
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> makes_copy(x); &lt;span style="color:#75715e">// x 应该移动函数里，
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 但 i32 是 Copy 的，
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 所以在后面可继续使用 x
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#75715e">// 这里，x 先移出了作用域，然后是 s。但因为 s 的值已被移走，所以不会发生改变
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">takes_ownership&lt;/span>(some_string: String) { &lt;span style="color:#75715e">// some_string 进入作用域
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> println!(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">{}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, some_string);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#75715e">// 这里，some_string 移出作用域并调用 `drop` 方法。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 占用的内存被释放
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">makes_copy&lt;/span>(some_integer: &lt;span style="color:#66d9ef">i32&lt;/span>) { &lt;span style="color:#75715e">// some_integer 进入作用域
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> println!(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">{}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, some_integer);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#75715e">// some_integer 移出作用域
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="返回值与作用域">返回值与作用域&lt;/h3>
&lt;p>返回值也可以转移所有权。&lt;/p></description></item><item><title>Bitcoin</title><link>/posts/public/crypto/crypto-bitcoin/</link><pubDate>Sat, 01 Apr 2023 00:00:00 +0000</pubDate><guid>/posts/public/crypto/crypto-bitcoin/</guid><description>&lt;h1 id="bitcoin">Bitcoin&lt;/h1></description></item><item><title>Markdown Syntax Guide</title><link>/posts/public/temp/markdown-syntax/</link><pubDate>Mon, 11 Mar 2019 00:00:00 +0000</pubDate><guid>/posts/public/temp/markdown-syntax/</guid><description>&lt;p>This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.&lt;/p></description></item><item><title>Rich Content</title><link>/posts/public/temp/rich-content/</link><pubDate>Sun, 10 Mar 2019 00:00:00 +0000</pubDate><guid>/posts/public/temp/rich-content/</guid><description>&lt;p>Hugo ships with several &lt;a href="https://gohugo.io/content-management/shortcodes/#use-hugos-built-in-shortcodes">Built-in Shortcodes&lt;/a> for rich content, along with a &lt;a href="https://gohugo.io/about/hugo-and-gdpr/">Privacy Config&lt;/a> and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.&lt;/p>
&lt;h2 id="heading">&lt;/h2></description></item><item><title>Math Typesetting</title><link>/posts/public/temp/math-typesetting/</link><pubDate>Fri, 08 Mar 2019 00:00:00 +0000</pubDate><guid>/posts/public/temp/math-typesetting/</guid><description>&lt;p>Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.&lt;/p></description></item><item><title/><link>/posts/public/rust/fn-fnmut-and-fnonce/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/public/rust/fn-fnmut-and-fnonce/</guid><description>&lt;p>The traits each represent more and more restrictive properties about closures/functions, indicated by the signatures of their &lt;code>call_...&lt;/code> method, and particularly the type of &lt;code>self&lt;/code>:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html">&lt;code>FnOnce&lt;/code>&lt;/a> (&lt;code>self&lt;/code>) are functions that can be called once&lt;/li>
&lt;li>&lt;a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html">&lt;code>FnMut&lt;/code>&lt;/a> (&lt;code>&amp;amp;mut self&lt;/code>) are functions that can be called if they have &lt;code>&amp;amp;mut&lt;/code> access to their environment&lt;/li>
&lt;li>&lt;a href="https://doc.rust-lang.org/std/ops/trait.Fn.html">&lt;code>Fn&lt;/code>&lt;/a> (&lt;code>&amp;amp;self&lt;/code>) are functions that can be called if they only have &lt;code>&amp;amp;&lt;/code> access to their environment&lt;/li>
&lt;/ul>
&lt;p>A closure &lt;code>|...| ...&lt;/code> will automatically implement as many of those as it can.&lt;/p></description></item></channel></rss>