<!doctype html><html class="not-ready lg:text-base" style=--bg:#faf8f1 lang=zh-cn><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Rust Ownership - Paper</title>
<meta name=theme-color><meta name=description content='所有权 每一个值都有一个所有者 At any given time, you can have either (but not both) one mutable reference or any number of immutable references. References must always be valid. 将值赋给另一个变量（包含函数实参）时移动它 当持有堆中数据值的变量离开作用域时，其值将通过 drop 被清理掉，除非数据被移动为另一个变量所有 所有权与函数 fn main() { let s = String::from("hello"); // s 进入作用域 takes_ownership(s); // s 的值移动到函数里 ... // ... 所以到这里不再有效 let x = 5; // x 进入作用域 makes_copy(x); // x 应该移动函数里， // 但 i32 是 Copy 的， // 所以在后面可继续使用 x } // 这里，x 先移出了作用域，然后是 s。但因为 s 的值已被移走，所以不会发生改变 fn takes_ownership(some_string: String) { // some_string 进入作用域 println!'><meta name=author content="Sricor"><link rel="preload stylesheet" as=style href=/main.min.css><link rel=preload as=image href=/theme.svg><link rel=preload as=image href=/twitter.svg><link rel=preload as=image href=/github.svg><script defer src=/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css integrity=sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js integrity=sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",()=>renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1}))</script><link rel=icon href=/favicon.ico><link rel=apple-touch-icon href=/apple-touch-icon.png><meta name=generator content="Hugo 0.127.0"><meta itemprop=name content="Rust Ownership"><meta itemprop=description content='所有权 每一个值都有一个所有者 At any given time, you can have either (but not both) one mutable reference or any number of immutable references. References must always be valid. 将值赋给另一个变量（包含函数实参）时移动它 当持有堆中数据值的变量离开作用域时，其值将通过 drop 被清理掉，除非数据被移动为另一个变量所有 所有权与函数 fn main() { let s = String::from("hello"); // s 进入作用域 takes_ownership(s); // s 的值移动到函数里 ... // ... 所以到这里不再有效 let x = 5; // x 进入作用域 makes_copy(x); // x 应该移动函数里， // 但 i32 是 Copy 的， // 所以在后面可继续使用 x } // 这里，x 先移出了作用域，然后是 s。但因为 s 的值已被移走，所以不会发生改变 fn takes_ownership(some_string: String) { // some_string 进入作用域 println!'><meta itemprop=datePublished content="2023-12-09T00:00:00+00:00"><meta itemprop=dateModified content="2023-12-09T00:00:00+00:00"><meta itemprop=wordCount content="480"><meta itemprop=keywords content="Rust,Programming"><meta property="og:url" content="/posts/public/rust/ownership/"><meta property="og:site_name" content="Paper"><meta property="og:title" content="Rust Ownership"><meta property="og:description" content='所有权 每一个值都有一个所有者 At any given time, you can have either (but not both) one mutable reference or any number of immutable references. References must always be valid. 将值赋给另一个变量（包含函数实参）时移动它 当持有堆中数据值的变量离开作用域时，其值将通过 drop 被清理掉，除非数据被移动为另一个变量所有 所有权与函数 fn main() { let s = String::from("hello"); // s 进入作用域 takes_ownership(s); // s 的值移动到函数里 ... // ... 所以到这里不再有效 let x = 5; // x 进入作用域 makes_copy(x); // x 应该移动函数里， // 但 i32 是 Copy 的， // 所以在后面可继续使用 x } // 这里，x 先移出了作用域，然后是 s。但因为 s 的值已被移走，所以不会发生改变 fn takes_ownership(some_string: String) { // some_string 进入作用域 println!'><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-09T00:00:00+00:00"><meta property="article:modified_time" content="2023-12-09T00:00:00+00:00"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Programming"><meta name=twitter:card content="summary"><meta name=twitter:title content="Rust Ownership"><meta name=twitter:description content='所有权 每一个值都有一个所有者 At any given time, you can have either (but not both) one mutable reference or any number of immutable references. References must always be valid. 将值赋给另一个变量（包含函数实参）时移动它 当持有堆中数据值的变量离开作用域时，其值将通过 drop 被清理掉，除非数据被移动为另一个变量所有 所有权与函数 fn main() { let s = String::from("hello"); // s 进入作用域 takes_ownership(s); // s 的值移动到函数里 ... // ... 所以到这里不再有效 let x = 5; // x 进入作用域 makes_copy(x); // x 应该移动函数里， // 但 i32 是 Copy 的， // 所以在后面可继续使用 x } // 这里，x 先移出了作用域，然后是 s。但因为 s 的值已被移走，所以不会发生改变 fn takes_ownership(some_string: String) { // some_string 进入作用域 println!'><link rel=canonical href=/posts/public/rust/ownership/></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-3xl px-8 lg:justify-center"><div class="relative z-50 mr-auto flex items-center"><a class="-translate-x-[1px] -translate-y-[1px] text-2xl font-semibold" href=/>Paper</a><div class="btn-dark text-[0] ml-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.svg)_left_center/cover_no-repeat] dark:invert dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 -mr-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#faf8f1".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"><nav class="mt-12 flex justify-center space-x-10 dark:invert lg:ml-12 lg:mt-0 lg:items-center lg:space-x-6"><a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./twitter.svg) href=https://twitter.com/josricor target=_blank rel=me>twitter
</a><a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./github.svg) href=https://github.com/Sricor target=_blank rel=me>github</a></nav></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-3xl px-8 pb-16 pt-12 dark:prose-invert"><article><header class=mb-16><h1 class="!my-0 pb-2.5">Rust Ownership</h1><div class="text-sm antialiased opacity-60"><time>Dec 9, 2023</time>
<span class=mx-1>&#183;</span>
<span>Sricor</span></div></header><section><h3 id=所有权>所有权</h3><blockquote><ul><li>每一个值都有一个<strong>所有者</strong></li><li>At any given time, you can have <em>either</em> (but not both) one mutable reference or any number of immutable references.</li><li>References must always be valid.</li><li>将值赋给另一个变量（包含函数实参）时移动它</li><li>当持有堆中数据值的变量离开作用域时，其值将通过 <code>drop</code> 被清理掉，除非数据被移动为另一个变量所有</li></ul></blockquote><h4 id=所有权与函数>所有权与函数</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> s <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello&#34;</span>);  <span style=color:#75715e>// s 进入作用域
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    takes_ownership(s);             <span style=color:#75715e>// s 的值移动到函数里 ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                    <span style=color:#75715e>// ... 所以到这里不再有效
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;                      <span style=color:#75715e>// x 进入作用域
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    makes_copy(x);                  <span style=color:#75715e>// x 应该移动函数里，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                    <span style=color:#75715e>// 但 i32 是 Copy 的，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                    <span style=color:#75715e>// 所以在后面可继续使用 x
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>} <span style=color:#75715e>// 这里，x 先移出了作用域，然后是 s。但因为 s 的值已被移走，所以不会发生改变
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>takes_ownership</span>(some_string: String) { <span style=color:#75715e>// some_string 进入作用域
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, some_string);
</span></span><span style=display:flex><span>} <span style=color:#75715e>// 这里，some_string 移出作用域并调用 `drop` 方法。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// 占用的内存被释放
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>makes_copy</span>(some_integer: <span style=color:#66d9ef>i32</span>) { <span style=color:#75715e>// some_integer 进入作用域
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, some_integer);
</span></span><span style=display:flex><span>} <span style=color:#75715e>// some_integer 移出作用域
</span></span></span></code></pre></div><h3 id=返回值与作用域>返回值与作用域</h3><p>返回值也可以转移所有权。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> s1 <span style=color:#f92672>=</span> gives_ownership();         <span style=color:#75715e>// gives_ownership 将返回值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                        <span style=color:#75715e>// 转移给 s1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> s2 <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello&#34;</span>);     <span style=color:#75715e>// s2 进入作用域
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> s3 <span style=color:#f92672>=</span> takes_and_gives_back(s2);  <span style=color:#75715e>// s2 被移动到
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                        <span style=color:#75715e>// takes_and_gives_back 中，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                        <span style=color:#75715e>// 它也将返回值移给 s3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>} <span style=color:#75715e>// s3 移出作用域并被丢弃。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// s2 也移出作用域，但已被移走，所以什么也不会发生。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// s1 离开作用域并被丢弃。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>gives_ownership</span>() -&gt; String {             <span style=color:#75715e>// gives_ownership 会将
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                             <span style=color:#75715e>// 返回值移动给
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                             <span style=color:#75715e>// 调用它的函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> some_string <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;yours&#34;</span>); <span style=color:#75715e>// some_string 进入作用域。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    some_string                              <span style=color:#75715e>// 返回 some_string 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                             <span style=color:#75715e>// 并移出给调用的函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                             <span style=color:#75715e>// 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// takes_and_gives_back 将传入字符串并返回该值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>takes_and_gives_back</span>(a_string: String) -&gt; String { <span style=color:#75715e>// a_string 进入作用域
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                                      <span style=color:#75715e>// 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    a_string  <span style=color:#75715e>// 返回 a_string 并移出给调用的函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>使用元组来返回多个值</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> s1 <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (s2, len) <span style=color:#f92672>=</span> calculate_length(s1);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;The length of &#39;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#39; is </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>.&#34;</span>, s2, len);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>calculate_length</span>(s: String) -&gt; (String, <span style=color:#66d9ef>usize</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> length <span style=color:#f92672>=</span> s.len(); <span style=color:#75715e>// len() 返回字符串的长度
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    (s, length)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>变量的所有权总是遵循相同的模式：<strong>将值赋给另一个变量（包含函数实参）时移动它</strong>。
<strong>当持有堆中数据值的变量离开作用域时，其值将通过 <code>drop</code> 被清理掉，除非数据被移动为另一个变量所有。</strong></p><h4 id=变量与数据交互的方式一移动>变量与数据交互的方式（一）：移动</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>; 
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> y <span style=color:#f92672>=</span> x;
</span></span></code></pre></div><p>将 <code>5</code> 绑定到 <code>x</code>，接着生成一个值 <code>x</code> 的拷贝并绑定到 <code>y</code>。
现在有了两个变量，<code>x</code> 和 <code>y</code>，都等于 <code>5</code>。
因为整数是有已知固定大小的简单值，所以这两个 <code>5</code> 被放入了栈中。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> s1 <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello&#34;</span>); 
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> s2 <span style=color:#f92672>=</span> s1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Error borrow of moved value: `s1`
</span></span></span><span style=display:flex><span><span style=color:#75715e>// println!(&#34;{}, world!&#34;, s1);  // s1 不再有效
</span></span></span></code></pre></div><ul><li>假如 <code>s2</code> 同时拷贝 <code>s1</code> 栈与堆的数据，当数据量比较大的时候会对性能造成非常大的影响</li><li>假如 <code>s2</code> 只拷贝 <code>s1</code> 栈上的数据，而不拷贝堆上数据，当 <code>s2</code> 与 <code>s1</code> 离开作用域时，自动调用 <code>drop</code> 函数并尝试释放相同的堆内存，会出现二次释放错误，可能会导致潜在的安全漏洞
<strong>为了确保内存安全，在 <code>let s2 = s1;</code> 之后，<code>s1</code> 被移动到了 <code>s2</code>，<code>s1</code>将不再有效</strong>
![[Drawing 2023-11-19 19.57.45.excalidraw.svg]]
Rust 永远也不会自动创建数据的 “深拷贝”，任何 <strong>自动</strong> 的复制都可以被认为是对运行时性能影响较小的。</li></ul><h4 id=变量与数据交互的方式二克隆>变量与数据交互的方式（二）：克隆</h4><p>如果我们 <strong>确实</strong> 需要深度复制 <code>String</code> 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 <code>clone</code> 的通用函数，这可能相当消耗资源。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> s1 <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> s2 <span style=color:#f92672>=</span> s1.clone();  <span style=color:#75715e>// 堆上的数据被复制了
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>println!(<span style=color:#e6db74>&#34;s1 = </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>, s2 = </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, s1, s2);
</span></span></code></pre></div><p>对于只在栈上的数据，是直接克隆的。
编译时已知大小的类型被整个存储在栈上，所以拷贝其实际的值是快速的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>; 
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> y <span style=color:#f92672>=</span> x; 
</span></span><span style=display:flex><span>println!(<span style=color:#e6db74>&#34;x = </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>, y = </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, x, y);
</span></span></code></pre></div><p>如果一个类型实现了 <code>Copy</code> trait，那么一个旧的变量在将其赋值给其他变量后仍然可用。</p><p><strong>实现了 <code>Copy</code> trait的类型</strong>
任何一组简单标量值的组合都可以实现 <code>Copy</code>
任何不需要分配内存或某种形式资源的类型都可以实现 <code>Copy</code>，如下：</p><ul><li>所有整数类型</li><li>所有浮点数类型</li><li>布尔类型</li><li>字符类型</li><li>元组（当且仅当其包含的所以元素类型也都实现 <code>Copy</code> ）</li></ul><p>Rust 不允许自身或其任何部分实现了 <code>Drop</code> trait 的类型使用 <code>Copy</code> trait</p><h4 id=内存与分配>内存与分配</h4><p>字符串字面值在编译时就知道其内容，所以文本被直接硬编码进最终的可执行文件中。这使得字符串字面值快速且高效，不过这些特性都只得益于字符串字面值的不可变性。</p><p>对于 <code>String</code> 为了支持一个可变，可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容，意味着需要：</p><ol><li>必须在运行时向内存分配器（<em>Memory Allocator</em>）请求内存</li><li>需要一个当我们处理完 <code>String</code> 时将内存返回给分配器的方法</li></ol><p>第一部分由我们完成：当调用 <code>String::from</code> 时，它的实现请求其所需的内存。
第二部分由Rust完成：当变量离开作用域，Rust 在结尾的 <code>}</code> 处自动调用 <code>drop</code>，内存在拥有它的变量离开作用域后就被自动释放。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>let</span> s <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello&#34;</span>); <span style=color:#75715e>// 从此处起，s 是有效的
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>}                                  <span style=color:#75715e>// 此作用域已结束，s 不再有效
</span></span></span></code></pre></div><p>在生命周期结束时释放资源的模式被称作 <strong>资源获取即初始化</strong>（<em>Resource Acquisition Is Initialization (RAII)</em>）。</p><h3 id=切片类型>切片类型</h3><p>在 Rust 中，切片（slice）是对集合中一部分元素的引用，允许你引用集合中的连续或非连续的元素序列而无需复制数据。切片是一种轻量级的数据结构，主要有两种类型：数组切片和字符串切片。</p><ol><li><p>数组切片：</p><ul><li>对于数组，切片是对数组的引用，指定了数组的一部分。</li><li>语法示例：&amp;array[start..end]，其中 start 是起始索引，end 是结束索引。</li><li>例如：
let my_array = [1, 2, 3, 4, 5];
let my_slice = &amp;my_array[1..4];</li></ul></li><li><p>字符串切片：</p><ul><li>对于字符串，切片是对字符串的引用，指定了字符串的一部分。</li><li>语法示例：&amp;str[start..end]，其中 start 是起始索引，end 是结束索引。</li><li>例如：
let my_string = &ldquo;Hello, World!&rdquo;;
let my_slice = &amp;my_string[7..12];</li></ul></li></ol><p>切片的使用使得你能够在不拥有整个集合所有权的情况下，访问集合的一部分。切片是一个很重要的 Rust 特性，它在处理数据时允许更灵活的操作，而不会引入额外的性能开销。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> s <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello world&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> hello <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>s[<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span><span style=color:#ae81ff>5</span>];  <span style=color:#75715e>// &amp;str
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> world <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>s[<span style=color:#ae81ff>6</span><span style=color:#f92672>..</span><span style=color:#ae81ff>11</span>];
</span></span></code></pre></div></section><footer class="mt-12 flex flex-wrap"><a class="mb-1.5 mr-1.5 rounded-lg bg-black/[3%] px-5 py-1.5 no-underline dark:bg-white/[8%]" href=/tags/rust>Rust</a>
<a class="mb-1.5 mr-1.5 rounded-lg bg-black/[3%] px-5 py-1.5 no-underline dark:bg-white/[8%]" href=/tags/programming>Programming</a></footer></article></main><footer class="opaco mx-auto flex h-[4.5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"><div class=mr-auto>&copy; 2024
<a class=link href=/>Paper</a></div></footer></body></html>