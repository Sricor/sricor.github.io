<!doctype html><html class="not-ready lg:text-base" style=--bg:#faf8f1 lang=zh-cn><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Rust Smart Pointers - Paper</title>
<meta name=theme-color><meta name=description content="Box<T> allow to store data on the heap. Box<T> is a pointer, point to data on the heap. when a box goes out of scope, it will be deallocated because of the Drop trait implementation(both for the heap and stack). implementing the Deref trait allows to customize the behavior of the dereference operator *. implementing the Drop trait, rust automatically called drop when instances went out of scope. not allowed to explicitly call drop."><meta name=author content="Sricor"><link rel="preload stylesheet" as=style href=https://sricor.github.io/main.min.css><link rel=preload as=image href=https://sricor.github.io/theme.svg><link rel=preload as=image href=https://sricor.github.io/twitter.svg><link rel=preload as=image href=https://sricor.github.io/github.svg><script defer src=https://sricor.github.io/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css integrity=sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js integrity=sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",()=>renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1}))</script><link rel=icon href=https://sricor.github.io/favicon.ico><link rel=apple-touch-icon href=https://sricor.github.io/apple-touch-icon.png><meta name=generator content="Hugo 0.121.1"><meta itemprop=name content="Rust Smart Pointers"><meta itemprop=description content="Box<T> allow to store data on the heap. Box<T> is a pointer, point to data on the heap. when a box goes out of scope, it will be deallocated because of the Drop trait implementation(both for the heap and stack). implementing the Deref trait allows to customize the behavior of the dereference operator *. implementing the Drop trait, rust automatically called drop when instances went out of scope. not allowed to explicitly call drop."><meta itemprop=datePublished content="2023-12-12T00:00:00+00:00"><meta itemprop=dateModified content="2023-12-12T00:00:00+00:00"><meta itemprop=wordCount content="1826"><meta itemprop=keywords content="Rust,Programming,"><meta property="og:title" content="Rust Smart Pointers"><meta property="og:description" content="Box<T> allow to store data on the heap. Box<T> is a pointer, point to data on the heap. when a box goes out of scope, it will be deallocated because of the Drop trait implementation(both for the heap and stack). implementing the Deref trait allows to customize the behavior of the dereference operator *. implementing the Drop trait, rust automatically called drop when instances went out of scope. not allowed to explicitly call drop."><meta property="og:type" content="article"><meta property="og:url" content="https://sricor.github.io/posts/public/rust/smart-pointers/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-12T00:00:00+00:00"><meta property="article:modified_time" content="2023-12-12T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Rust Smart Pointers"><meta name=twitter:description content="Box<T> allow to store data on the heap. Box<T> is a pointer, point to data on the heap. when a box goes out of scope, it will be deallocated because of the Drop trait implementation(both for the heap and stack). implementing the Deref trait allows to customize the behavior of the dereference operator *. implementing the Drop trait, rust automatically called drop when instances went out of scope. not allowed to explicitly call drop."><link rel=canonical href=https://sricor.github.io/posts/public/rust/smart-pointers/></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-3xl px-8 lg:justify-center"><div class="relative z-50 mr-auto flex items-center"><a class="-translate-x-[1px] -translate-y-[1px] text-2xl font-semibold" href=https://sricor.github.io/>Paper</a><div class="btn-dark text-[0] ml-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.svg)_left_center/cover_no-repeat] dark:invert dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 -mr-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#faf8f1".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"><nav class="mt-12 flex justify-center space-x-10 dark:invert lg:ml-12 lg:mt-0 lg:items-center lg:space-x-6"><a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./twitter.svg) href=https://twitter.com/josricor target=_blank rel=me>twitter
</a><a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./github.svg) href=https://github.com/Sricor target=_blank rel=me>github</a></nav></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-3xl px-8 pb-16 pt-12 dark:prose-invert"><article><header class=mb-16><h1 class="!my-0 pb-2.5">Rust Smart Pointers</h1><div class="text-sm antialiased opacity-60"><time>Dec 12, 2023</time>
<span class=mx-1>&#183;</span>
<span>Sricor</span></div></header><section><blockquote><ul><li><code>Box&lt;T></code> allow to store data on the heap.</li><li><code>Box&lt;T></code> is a pointer, point to data on the heap.</li><li>when a box goes out of scope, it will be deallocated because of the <code>Drop</code> trait implementation(both for the heap and stack).</li></ul></blockquote><blockquote><ul><li>implementing the <code>Deref</code> trait allows to customize the behavior of the dereference operator <code>*</code>.</li></ul></blockquote><blockquote><ul><li>implementing the <code>Drop</code> trait, rust automatically called <code>drop</code> when instances went out of scope.</li><li>not allowed to explicitly call <code>drop</code>.</li><li>can drop a value early with <code>std::mem::drop</code>.</li><li>variables are dropped in the reverse order of their creation.</li></ul></blockquote><blockquote><ul><li><code>Rc&lt;T></code> allows a single value to have multiple owners.</li><li><code>Rc&lt;T></code> is only for use in single-threaded scenarios.</li><li><code>Rc::clone</code> does not make a deep copy, it does not take much time.</li><li><code>Drop</code> trait decreases the reference count automatically when an <code>Rc&lt;T></code> value goes out of scope</li></ul></blockquote><h3 id=1-using-boxt-to-point-to-data-on-the-heaphttpsdocrust-langorgstablebookch15-01-boxhtml><a href=https://doc.rust-lang.org/stable/book/ch15-01-box.html>1. Using Box to Point to Data on the Heap</a></h3><p>Boxes allow to store data on the heap rather than the stack.</p><p>Will use them most often in these situations:</p><ul><li>have a type whose size can&rsquo;t be known at compile time</li><li>have a large amount of data and want to transfer ownership but ensure the data won&rsquo;t be copied</li><li>want to own a value and care only that it&rsquo;s a type that implements a particular trait rather than being of a specific type</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> b <span style=color:#f92672>=</span> Box::new(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;b = </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, b);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Define the variable <code>b</code> to have the value of a <code>Box</code> that points to the value <code>5</code>, which is allocated on the heap. When a box goes out of scope, as <code>b</code> does at the end of <code>main</code>, it will be deallocated. The deallocation happens both for the box (stored on the stack) and the data it points to (stored on the heap).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// This code does not compile
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>List</span> {
</span></span><span style=display:flex><span>    Cons(<span style=color:#66d9ef>i32</span>, List),
</span></span><span style=display:flex><span>    Nil,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> <span style=color:#66d9ef>crate</span>::List::{Cons, Nil};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> list <span style=color:#f92672>=</span> Cons(<span style=color:#ae81ff>1</span>, Cons(<span style=color:#ae81ff>2</span>, Cons(<span style=color:#ae81ff>3</span>, Nil)));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This code does not compile, Because Rust can’t figure out how much space to allocate for recursively defined types.</p><p><img src=https://doc.rust-lang.org/stable/book/img/trpl15-01.svg alt="An infinite List consisting of infinite Cons variants"></p><p>Put a <code>Box&lt;T></code> inside the <code>Cons</code> variant instead of another <code>List</code> value directly. The <code>Box&lt;T></code> will point to the next <code>List</code> value that will be on the heap rather than inside the <code>Cons</code> variant.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>List</span> {
</span></span><span style=display:flex><span>    Cons(<span style=color:#66d9ef>i32</span>, Box<span style=color:#f92672>&lt;</span>List<span style=color:#f92672>&gt;</span>),
</span></span><span style=display:flex><span>    Nil,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> <span style=color:#66d9ef>crate</span>::List::{Cons, Nil};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> list <span style=color:#f92672>=</span> Cons(<span style=color:#ae81ff>1</span>, Box::new(Cons(<span style=color:#ae81ff>2</span>, Box::new(Cons(<span style=color:#ae81ff>3</span>, Box::new(Nil))))));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Because a <code>Box&lt;T></code> is a pointer, Rust always knows how much space a <code>Box&lt;T></code> needs: a pointer’s size doesn’t change based on the amount of data it’s pointing to.
We now know that any <code>List</code> value will take up the size of an <code>i32</code> plus the size of a box’s pointer data. By using a box broken the infinite, recursive chain, so the compiler can figure out the size it needs to store a <code>List</code> value.</p><p><img src=https://doc.rust-lang.org/stable/book/img/trpl15-02.svg alt="A List that is not infinitely sized because Cons holds a Box"></p><p>Boxes provide only the indirection and heap allocation,  they don’t have any other special capabilities.</p><p>The <code>Box&lt;T></code> type is a smart pointer because it implements the <code>Deref</code> trait, which allows <code>Box&lt;T></code> values to be treated like references. When a <code>Box&lt;T></code> value goes out of scope, the heap data that the box is pointing to is cleaned up as well because of the <code>Drop</code> trait implementation.</p><h3 id=2-treating-smart-pointers-like-regular-references-with-thedereftraithttpsdocrust-langorgstablebookch15-02-derefhtml><a href=https://doc.rust-lang.org/stable/book/ch15-02-deref.html>2. Treating Smart Pointers Like Regular References with the <code>Deref</code> Trait</a></h3><p>Implementing the <code>Deref</code> trait allows to customize the behavior of the <em>dereference operator</em> <code>*</code></p><p>By implementing <code>Deref</code> in such a way that a smart pointer can be treated like a regular reference, you can write code that operates on references and use that code with smart pointers too.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// This code does not compile
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Using Box&lt;T&gt; Like a Reference
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>MyBox</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>(T);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> MyBox<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>(x: <span style=color:#a6e22e>T</span>) -&gt; <span style=color:#a6e22e>MyBox</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        MyBox(x)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> y <span style=color:#f92672>=</span> MyBox::new(x);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    assert_eq!(<span style=color:#ae81ff>5</span>, x);
</span></span><span style=display:flex><span>    assert_eq!(<span style=color:#ae81ff>5</span>, <span style=color:#f92672>*</span>y);  <span style=color:#75715e>// error: type `MyBox&lt;{integer}&gt;` cannot be dereferenced
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p><code>MyBox&lt;T></code> type can’t be dereferenced because we haven’t implemented that ability on our type. To enable dereferencing with the <code>*</code> operator, we implement the <code>Deref</code> trait.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::ops::Deref;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> Deref <span style=color:#66d9ef>for</span> MyBox<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Target</span> <span style=color:#f92672>=</span> T;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>deref</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Self</span>::Target {
</span></span><span style=display:flex><span>        <span style=color:#f92672>&amp;</span>self.<span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Without the <code>Deref</code> trait, the compiler can only dereference <code>&</code> references. The <code>deref</code> method gives the compiler the ability to take a value of any type that implements <code>Deref</code> and call the <code>deref</code> method to get a <code>&</code> reference that it knows how to dereference.</p><p>When we entered <code>*y</code>, behind the scenes Rust actually ran this code <code>*(y.deref())</code>.
The <code>*</code> operator is replaced with a call to the <code>deref</code> method and then a call to the <code>*</code> operator just once, each time we use a <code>*</code> in our code. Because the substitution of the <code>*</code> operator does not recurse infinitely.</p><h4 id=implicit-deref-coercions-with-functions-and-methods>Implicit Deref Coercions with Functions and Methods</h4><p><em>Deref coercion</em> converts a reference to a type that implements the <code>Deref</code> trait into a reference to another type. For example, deref coercion can convert <code>&amp;String</code> to <code>&amp;str</code> because <code>String</code> implements the <code>Deref</code> trait such that it returns <code>&amp;str</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>hello</span>(name: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;Hello, </span><span style=color:#e6db74>{name}</span><span style=color:#e6db74>!&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> m <span style=color:#f92672>=</span> MyBox::new(String::from(<span style=color:#e6db74>&#34;Rust&#34;</span>));
</span></span><span style=display:flex><span>    hello(<span style=color:#f92672>&amp;</span>m);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// If Rust didn’t implement deref coercion
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// hello(&amp;(*m)[..]);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>When the <code>Deref</code> trait is defined for the types involved, Rust will analyze the types and use <code>Deref::deref</code> as many times as necessary to get a reference to match the parameter’s type. The number of times that <code>Deref::deref</code> needs to be inserted is resolved at compile time, so there is no runtime penalty for taking advantage of deref coercion.</p><h4 id=how-deref-coercion-interacts-with-mutability>How Deref Coercion Interacts with Mutability</h4><ul><li>From <code>&amp;T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U></code></li><li>From <code>&amp;mut T</code> to <code>&amp;mut U</code> when <code>T: DerefMut&lt;Target=U></code></li><li>From <code>&amp;mut T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U></code></li></ul><h3 id=3-running-code-on-cleanup-with-the-drop-traithttpsdocrust-langorgstablebookch15-03-drophtml><a href=https://doc.rust-lang.org/stable/book/ch15-03-drop.html>3. Running Code on Cleanup with the Drop Trait</a></h3><p>Specify the code to run when a value goes out of scope by implementing the <code>Drop</code> trait. The <code>Drop</code> trait requires you to implement one method named <code>drop</code> that takes a mutable reference to <code>self</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>CustomSmartPointer</span> {
</span></span><span style=display:flex><span>    data: String,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Drop <span style=color:#66d9ef>for</span> CustomSmartPointer {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>drop</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) {
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;Dropping CustomSmartPointer with data `</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>`!&#34;</span>, self.data);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> c <span style=color:#f92672>=</span> CustomSmartPointer {
</span></span><span style=display:flex><span>        data: String::from(<span style=color:#e6db74>&#34;my stuff&#34;</span>),
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> d <span style=color:#f92672>=</span> CustomSmartPointer {
</span></span><span style=display:flex><span>        data: String::from(<span style=color:#e6db74>&#34;other stuff&#34;</span>),
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;CustomSmartPointers created.&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Rust doesn’t call <code>drop</code> explicitly because Rust would still automatically call <code>drop</code> on the value at the end of <code>main</code>. This would cause a <em>double free</em> error because Rust would be trying to clean up the same value twice.</p><h4 id=dropping-a-value-early-with-stdmemdrop>Dropping a Value Early with std::mem::drop</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> c <span style=color:#f92672>=</span> CustomSmartPointer {
</span></span><span style=display:flex><span>        data: String::from(<span style=color:#e6db74>&#34;some data&#34;</span>),
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;CustomSmartPointer created.&#34;</span>);
</span></span><span style=display:flex><span>    drop(c);
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;CustomSmartPointer dropped before the end of main.&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=4-rct-the-reference-counted-smart-pointerhttpsdocrust-langorgstablebookch15-04-rchtml><a href=https://doc.rust-lang.org/stable/book/ch15-04-rc.html>4. Rc, the Reference Counted Smart Pointer</a></h3><p>Enable multiple ownership explicitly by using the Rust type <code>Rc&lt;T></code>, which is an abbreviation for <em>reference counting</em>. The <code>Rc&lt;T></code> type keeps track of the number of references to a value to determine whether or not the value is still in use. If there are zero references to a value, the value can be cleaned up without any references becoming invalid.</p><p>We use the <code>Rc&lt;T></code> type when we want to allocate some data on the heap for multiple parts of our program to read and we can’t determine at compile time which part will finish using the data last. If we knew which part would finish last, we could just make that part the data’s owner, and the normal ownership rules enforced at compile time would take effect.</p><p> <code>Rc&lt;T></code> is only for use in single-threaded scenarios.</p><h4 id=using-rct-to-share-data>Using Rc to Share Data</h4><p><img src=https://doc.rust-lang.org/stable/book/img/trpl15-03.svg alt="Two lists, b and c, sharing ownership of a third list, a"></p><p>Trying to implement this scenario using our definition of <code>List</code> with <code>Box&lt;T></code> won’t work</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// This code does not compile
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>List</span> {
</span></span><span style=display:flex><span>    Cons(<span style=color:#66d9ef>i32</span>, Box<span style=color:#f92672>&lt;</span>List<span style=color:#f92672>&gt;</span>),
</span></span><span style=display:flex><span>    Nil,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> <span style=color:#66d9ef>crate</span>::List::{Cons, Nil};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> Cons(<span style=color:#ae81ff>5</span>, Box::new(Cons(<span style=color:#ae81ff>10</span>, Box::new(Nil))));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> b <span style=color:#f92672>=</span> Cons(<span style=color:#ae81ff>3</span>, Box::new(a));   <span style=color:#75715e>// error: use of moved value: `a`
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> c <span style=color:#f92672>=</span> Cons(<span style=color:#ae81ff>4</span>, Box::new(a));   <span style=color:#75715e>// error: value used here after move
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>when try to use <code>a</code> again when creating <code>c</code>, not allowed to because <code>a</code> has been moved.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>List</span> {
</span></span><span style=display:flex><span>    Cons(<span style=color:#66d9ef>i32</span>, Rc<span style=color:#f92672>&lt;</span>List<span style=color:#f92672>&gt;</span>),
</span></span><span style=display:flex><span>    Nil,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> <span style=color:#66d9ef>crate</span>::List::{Cons, Nil};
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> std::rc::Rc;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> Rc::new(Cons(<span style=color:#ae81ff>5</span>, Rc::new(Cons(<span style=color:#ae81ff>10</span>, Rc::new(Nil)))));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> b <span style=color:#f92672>=</span> Cons(<span style=color:#ae81ff>3</span>, Rc::clone(<span style=color:#f92672>&amp;</span>a));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> c <span style=color:#f92672>=</span> Cons(<span style=color:#ae81ff>4</span>, Rc::clone(<span style=color:#f92672>&amp;</span>a));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Change definition of <code>List</code> to use <code>Rc&lt;T></code> in place of <code>Box&lt;T></code>, Each <code>Cons</code> variant will now hold a value and an <code>Rc&lt;T></code> pointing to a <code>List</code>. When create <code>b</code>, instead of taking ownership of <code>a</code>, it will clone the <code>Rc&lt;List></code> that <code>a</code> is holding, thereby increasing the number of references from one to two and letting <code>a</code> and <code>b</code> share ownership of the data in that <code>Rc&lt;List></code>. it will also clone <code>a</code> when creating <code>c</code>, increasing the number of references from two to three. Every time call <code>Rc::clone</code>, the reference count to the data within the <code>Rc&lt;List></code> will increase, and the data won’t be cleaned up unless there are <strong>zero references</strong> to it.</p><p>Could have called <code>a.clone()</code> rather than <code>Rc::clone(&amp;a)</code>, but Rust’s convention is to use <code>Rc::clone</code> in this case. The implementation of <strong><code>Rc::clone</code> doesn’t make a deep copy</strong> of all the data like most types’ implementations of <code>clone</code> do. The call to <code>Rc::clone</code> only increments the reference count, which doesn’t take much time. Deep copies of data can take a lot of time. By using <code>Rc::clone</code> for reference counting, we can visually distinguish between the deep-copy kinds of clones and the kinds of clones that increase the reference count.</p><h4 id=cloning-anrctincreases-the-reference-count>Cloning an <code>Rc&lt;T></code> Increases the Reference Count</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> Rc::new(Cons(<span style=color:#ae81ff>5</span>, Rc::new(Cons(<span style=color:#ae81ff>10</span>, Rc::new(Nil)))));
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;count after creating a = </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, Rc::strong_count(<span style=color:#f92672>&amp;</span>a));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> b <span style=color:#f92672>=</span> Cons(<span style=color:#ae81ff>3</span>, Rc::clone(<span style=color:#f92672>&amp;</span>a));
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;count after creating b = </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, Rc::strong_count(<span style=color:#f92672>&amp;</span>a));
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> c <span style=color:#f92672>=</span> Cons(<span style=color:#ae81ff>4</span>, Rc::clone(<span style=color:#f92672>&amp;</span>a));
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;count after creating c = </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, Rc::strong_count(<span style=color:#f92672>&amp;</span>a));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;count after c goes out of scope = </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, Rc::strong_count(<span style=color:#f92672>&amp;</span>a));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>At each point in the program where the reference count changes, we print the reference count, which get by calling the <code>Rc::strong_count</code> function.</p><p>This code prints the following:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>count after creating a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>count after creating b <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>count after creating c <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>count after c goes out of scope <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>
</span></span></code></pre></div><p>The <code>Drop</code> trait decreases the reference count automatically when an <code>Rc&lt;T></code> value goes out of scope. Using <code>Rc&lt;T></code> allows a single value to have multiple owners, and the count ensures that the value remains valid as long as any of the owners still exist.</p><h3 id=refcellt-and-the-interior-mutability-patternhttpsdocrust-langorgstablebookch15-05-interior-mutabilityhtml><a href=https://doc.rust-lang.org/stable/book/ch15-05-interior-mutability.html>RefCell and the Interior Mutability Pattern</a></h3><p><em>Interior mutability</em> is a design pattern in Rust that allows you to mutate data even when there are immutable references to that data, To mutate data, the pattern uses <code>unsafe</code> code inside a data structure to bend Rust’s usual rules that govern mutation and borrowing. Unsafe code indicates to the compiler that we’re checking the rules manually instead of relying on the compiler to check them for us</p><p>由于 <code>Rust</code> 的 <code>mutable</code> 特性，一个结构体中的字段，要么全都是 <code>immutable</code>，要么全部是 <code>mutable</code>，<strong>不支持针对部分字段进行设置</strong>。比如，在一个 <code>struct</code> 中，<strong>可能只有个别的字段需要修改，而其他字段并不需要修改</strong>，为了一个字段而将整个 <code>struct</code> 变为 <code>&amp;mut</code> 也是不合理的。</p><p>所以，实现 <strong>内部可变性</strong> 的 <code>Cell</code> 和 <code>RefCell</code> 正是为了解决诸如这类问题存在的，通过它们可以实现 <code>struct</code> 部分字段可变，而不用将整个 <code>struct</code> 设置为 <code>mutable</code>。</p></section><footer class="mt-12 flex flex-wrap"><a class="mb-1.5 mr-1.5 rounded-lg bg-black/[3%] px-5 py-1.5 no-underline dark:bg-white/[8%]" href=https://sricor.github.io/tags/rust>Rust</a>
<a class="mb-1.5 mr-1.5 rounded-lg bg-black/[3%] px-5 py-1.5 no-underline dark:bg-white/[8%]" href=https://sricor.github.io/tags/programming>Programming</a></footer></article></main><footer class="opaco mx-auto flex h-[4.5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"><div class=mr-auto>&copy; 2023
<a class=link href=https://sricor.github.io/>Paper</a></div></footer></body></html>