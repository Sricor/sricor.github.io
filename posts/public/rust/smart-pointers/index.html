<!doctype html><html class="not-ready lg:text-base" style=--bg:#faf8f1 lang=zh-cn><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Rust Smart Pointers - Paper</title>
<meta name=theme-color><meta name=description content="Box<T> allow to store data on the heap. Box<T> is a pointer, point to data on the heap. when a box goes out of scope, it will be deallocated because of the Drop trait implementation(both for the heap and stack). implementing the Deref trait allows to customize the behavior of the dereference operator *. implementing the Drop trait, rust automatically called drop when instances went out of scope. not allowed to explicitly call drop."><meta name=author content="Sricor"><link rel="preload stylesheet" as=style href=https://sricor.github.io/main.min.css><link rel=preload as=image href=https://sricor.github.io/theme.svg><link rel=preload as=image href=https://sricor.github.io/twitter.svg><link rel=preload as=image href=https://sricor.github.io/github.svg><script defer src=https://sricor.github.io/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css integrity=sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js integrity=sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",()=>renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1}))</script><link rel=icon href=https://sricor.github.io/favicon.ico><link rel=apple-touch-icon href=https://sricor.github.io/apple-touch-icon.png><meta name=generator content="Hugo 0.121.1"><meta itemprop=name content="Rust Smart Pointers"><meta itemprop=description content="Box<T> allow to store data on the heap. Box<T> is a pointer, point to data on the heap. when a box goes out of scope, it will be deallocated because of the Drop trait implementation(both for the heap and stack). implementing the Deref trait allows to customize the behavior of the dereference operator *. implementing the Drop trait, rust automatically called drop when instances went out of scope. not allowed to explicitly call drop."><meta itemprop=datePublished content="2023-12-12T00:00:00+00:00"><meta itemprop=dateModified content="2023-12-12T00:00:00+00:00"><meta itemprop=wordCount content="1063"><meta itemprop=keywords content="Rust,Programming,"><meta property="og:title" content="Rust Smart Pointers"><meta property="og:description" content="Box<T> allow to store data on the heap. Box<T> is a pointer, point to data on the heap. when a box goes out of scope, it will be deallocated because of the Drop trait implementation(both for the heap and stack). implementing the Deref trait allows to customize the behavior of the dereference operator *. implementing the Drop trait, rust automatically called drop when instances went out of scope. not allowed to explicitly call drop."><meta property="og:type" content="article"><meta property="og:url" content="https://sricor.github.io/posts/public/rust/smart-pointers/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-12T00:00:00+00:00"><meta property="article:modified_time" content="2023-12-12T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Rust Smart Pointers"><meta name=twitter:description content="Box<T> allow to store data on the heap. Box<T> is a pointer, point to data on the heap. when a box goes out of scope, it will be deallocated because of the Drop trait implementation(both for the heap and stack). implementing the Deref trait allows to customize the behavior of the dereference operator *. implementing the Drop trait, rust automatically called drop when instances went out of scope. not allowed to explicitly call drop."><link rel=canonical href=https://sricor.github.io/posts/public/rust/smart-pointers/></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-3xl px-8 lg:justify-center"><div class="relative z-50 mr-auto flex items-center"><a class="-translate-x-[1px] -translate-y-[1px] text-2xl font-semibold" href=https://sricor.github.io/>Paper</a><div class="btn-dark text-[0] ml-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.svg)_left_center/cover_no-repeat] dark:invert dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 -mr-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#faf8f1".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"><nav class="mt-12 flex justify-center space-x-10 dark:invert lg:ml-12 lg:mt-0 lg:items-center lg:space-x-6"><a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./twitter.svg) href=https://twitter.com/josricor target=_blank rel=me>twitter
</a><a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./github.svg) href=https://github.com/Sricor target=_blank rel=me>github</a></nav></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-3xl px-8 pb-16 pt-12 dark:prose-invert"><article><header class=mb-16><h1 class="!my-0 pb-2.5">Rust Smart Pointers</h1><div class="text-sm antialiased opacity-60"><time>Dec 12, 2023</time>
<span class=mx-1>&#183;</span>
<span>Sricor</span></div></header><section><blockquote><ul><li><code>Box&lt;T></code> allow to store data on the heap.</li><li><code>Box&lt;T></code> is a pointer, point to data on the heap.</li><li>when a box goes out of scope, it will be deallocated because of the <code>Drop</code> trait implementation(both for the heap and stack).</li></ul></blockquote><blockquote><ul><li>implementing the <code>Deref</code> trait allows to customize the behavior of the dereference operator <code>*</code>.</li></ul></blockquote><blockquote><ul><li>implementing the <code>Drop</code> trait, rust automatically called <code>drop</code> when instances went out of scope.</li><li>not allowed to explicitly call <code>drop</code>.</li><li>can drop a value early with <code>std::mem::drop</code>.</li><li>variables are dropped in the reverse order of their creation.</li></ul></blockquote><h3 id=1-using-boxt-to-point-to-data-on-the-heaphttpsdocrust-langorgstablebookch15-01-boxhtml><a href=https://doc.rust-lang.org/stable/book/ch15-01-box.html>1. Using Box to Point to Data on the Heap</a></h3><p>Boxes allow to store data on the heap rather than the stack.</p><p>Will use them most often in these situations:</p><ul><li>have a type whose size can&rsquo;t be known at compile time</li><li>have a large amount of data and want to transfer ownership but ensure the data won&rsquo;t be copied</li><li>want to own a value and care only that it&rsquo;s a type that implements a particular trait rather than being of a specific type</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> b <span style=color:#f92672>=</span> Box::new(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;b = </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, b);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Define the variable <code>b</code> to have the value of a <code>Box</code> that points to the value <code>5</code>, which is allocated on the heap. When a box goes out of scope, as <code>b</code> does at the end of <code>main</code>, it will be deallocated. The deallocation happens both for the box (stored on the stack) and the data it points to (stored on the heap).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// This code does not compile
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>List</span> {
</span></span><span style=display:flex><span>    Cons(<span style=color:#66d9ef>i32</span>, List),
</span></span><span style=display:flex><span>    Nil,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> <span style=color:#66d9ef>crate</span>::List::{Cons, Nil};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> list <span style=color:#f92672>=</span> Cons(<span style=color:#ae81ff>1</span>, Cons(<span style=color:#ae81ff>2</span>, Cons(<span style=color:#ae81ff>3</span>, Nil)));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This code does not compile, Because Rust can’t figure out how much space to allocate for recursively defined types.</p><p><img src=https://doc.rust-lang.org/stable/book/img/trpl15-01.svg alt="An infinite List consisting of infinite Cons variants"></p><p>Put a <code>Box&lt;T></code> inside the <code>Cons</code> variant instead of another <code>List</code> value directly. The <code>Box&lt;T></code> will point to the next <code>List</code> value that will be on the heap rather than inside the <code>Cons</code> variant.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>List</span> {
</span></span><span style=display:flex><span>    Cons(<span style=color:#66d9ef>i32</span>, Box<span style=color:#f92672>&lt;</span>List<span style=color:#f92672>&gt;</span>),
</span></span><span style=display:flex><span>    Nil,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> <span style=color:#66d9ef>crate</span>::List::{Cons, Nil};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> list <span style=color:#f92672>=</span> Cons(<span style=color:#ae81ff>1</span>, Box::new(Cons(<span style=color:#ae81ff>2</span>, Box::new(Cons(<span style=color:#ae81ff>3</span>, Box::new(Nil))))));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Because a <code>Box&lt;T></code> is a pointer, Rust always knows how much space a <code>Box&lt;T></code> needs: a pointer’s size doesn’t change based on the amount of data it’s pointing to.
We now know that any <code>List</code> value will take up the size of an <code>i32</code> plus the size of a box’s pointer data. By using a box broken the infinite, recursive chain, so the compiler can figure out the size it needs to store a <code>List</code> value.</p><p><img src=https://doc.rust-lang.org/stable/book/img/trpl15-02.svg alt="A List that is not infinitely sized because Cons holds a Box"></p><p>Boxes provide only the indirection and heap allocation,  they don’t have any other special capabilities.</p><p>The <code>Box&lt;T></code> type is a smart pointer because it implements the <code>Deref</code> trait, which allows <code>Box&lt;T></code> values to be treated like references. When a <code>Box&lt;T></code> value goes out of scope, the heap data that the box is pointing to is cleaned up as well because of the <code>Drop</code> trait implementation.</p><h3 id=2-treating-smart-pointers-like-regular-references-with-thedereftraithttpsdocrust-langorgstablebookch15-02-derefhtml><a href=https://doc.rust-lang.org/stable/book/ch15-02-deref.html>2. Treating Smart Pointers Like Regular References with the <code>Deref</code> Trait</a></h3><p>Implementing the <code>Deref</code> trait allows to customize the behavior of the <em>dereference operator</em> <code>*</code></p><p>By implementing <code>Deref</code> in such a way that a smart pointer can be treated like a regular reference, you can write code that operates on references and use that code with smart pointers too.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// This code does not compile
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Using Box&lt;T&gt; Like a Reference
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>MyBox</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>(T);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> MyBox<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>(x: <span style=color:#a6e22e>T</span>) -&gt; <span style=color:#a6e22e>MyBox</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        MyBox(x)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> y <span style=color:#f92672>=</span> MyBox::new(x);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    assert_eq!(<span style=color:#ae81ff>5</span>, x);
</span></span><span style=display:flex><span>    assert_eq!(<span style=color:#ae81ff>5</span>, <span style=color:#f92672>*</span>y);  <span style=color:#75715e>// error: type `MyBox&lt;{integer}&gt;` cannot be dereferenced
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p><code>MyBox&lt;T></code> type can’t be dereferenced because we haven’t implemented that ability on our type. To enable dereferencing with the <code>*</code> operator, we implement the <code>Deref</code> trait.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::ops::Deref;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> Deref <span style=color:#66d9ef>for</span> MyBox<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Target</span> <span style=color:#f92672>=</span> T;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>deref</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Self</span>::Target {
</span></span><span style=display:flex><span>        <span style=color:#f92672>&amp;</span>self.<span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Without the <code>Deref</code> trait, the compiler can only dereference <code>&</code> references. The <code>deref</code> method gives the compiler the ability to take a value of any type that implements <code>Deref</code> and call the <code>deref</code> method to get a <code>&</code> reference that it knows how to dereference.</p><p>When we entered <code>*y</code>, behind the scenes Rust actually ran this code <code>*(y.deref())</code>.
The <code>*</code> operator is replaced with a call to the <code>deref</code> method and then a call to the <code>*</code> operator just once, each time we use a <code>*</code> in our code. Because the substitution of the <code>*</code> operator does not recurse infinitely.</p><h4 id=implicit-deref-coercions-with-functions-and-methods>Implicit Deref Coercions with Functions and Methods</h4><p><em>Deref coercion</em> converts a reference to a type that implements the <code>Deref</code> trait into a reference to another type. For example, deref coercion can convert <code>&amp;String</code> to <code>&amp;str</code> because <code>String</code> implements the <code>Deref</code> trait such that it returns <code>&amp;str</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>hello</span>(name: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;Hello, </span><span style=color:#e6db74>{name}</span><span style=color:#e6db74>!&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> m <span style=color:#f92672>=</span> MyBox::new(String::from(<span style=color:#e6db74>&#34;Rust&#34;</span>));
</span></span><span style=display:flex><span>    hello(<span style=color:#f92672>&amp;</span>m);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// If Rust didn’t implement deref coercion
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// hello(&amp;(*m)[..]);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>When the <code>Deref</code> trait is defined for the types involved, Rust will analyze the types and use <code>Deref::deref</code> as many times as necessary to get a reference to match the parameter’s type. The number of times that <code>Deref::deref</code> needs to be inserted is resolved at compile time, so there is no runtime penalty for taking advantage of deref coercion.</p><h4 id=how-deref-coercion-interacts-with-mutability>How Deref Coercion Interacts with Mutability</h4><ul><li>From <code>&amp;T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U></code></li><li>From <code>&amp;mut T</code> to <code>&amp;mut U</code> when <code>T: DerefMut&lt;Target=U></code></li><li>From <code>&amp;mut T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U></code></li></ul><h3 id=3-running-code-on-cleanup-with-the-drop-traithttpsdocrust-langorgstablebookch15-03-drophtml><a href=https://doc.rust-lang.org/stable/book/ch15-03-drop.html>3. Running Code on Cleanup with the Drop Trait</a></h3><p>Specify the code to run when a value goes out of scope by implementing the <code>Drop</code> trait. The <code>Drop</code> trait requires you to implement one method named <code>drop</code> that takes a mutable reference to <code>self</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>CustomSmartPointer</span> {
</span></span><span style=display:flex><span>    data: String,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Drop <span style=color:#66d9ef>for</span> CustomSmartPointer {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>drop</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) {
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;Dropping CustomSmartPointer with data `</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>`!&#34;</span>, self.data);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> c <span style=color:#f92672>=</span> CustomSmartPointer {
</span></span><span style=display:flex><span>        data: String::from(<span style=color:#e6db74>&#34;my stuff&#34;</span>),
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> d <span style=color:#f92672>=</span> CustomSmartPointer {
</span></span><span style=display:flex><span>        data: String::from(<span style=color:#e6db74>&#34;other stuff&#34;</span>),
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;CustomSmartPointers created.&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Rust doesn’t call <code>drop</code> explicitly because Rust would still automatically call <code>drop</code> on the value at the end of <code>main</code>. This would cause a <em>double free</em> error because Rust would be trying to clean up the same value twice.</p><h4 id=dropping-a-value-early-with-stdmemdrop>Dropping a Value Early with std::mem::drop</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> c <span style=color:#f92672>=</span> CustomSmartPointer {
</span></span><span style=display:flex><span>        data: String::from(<span style=color:#e6db74>&#34;some data&#34;</span>),
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;CustomSmartPointer created.&#34;</span>);
</span></span><span style=display:flex><span>    drop(c);
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;CustomSmartPointer dropped before the end of main.&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></section><footer class="mt-12 flex flex-wrap"><a class="mb-1.5 mr-1.5 rounded-lg bg-black/[3%] px-5 py-1.5 no-underline dark:bg-white/[8%]" href=https://sricor.github.io/tags/rust>Rust</a>
<a class="mb-1.5 mr-1.5 rounded-lg bg-black/[3%] px-5 py-1.5 no-underline dark:bg-white/[8%]" href=https://sricor.github.io/tags/programming>Programming</a></footer></article></main><footer class="opaco mx-auto flex h-[4.5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"><div class=mr-auto>&copy; 2023
<a class=link href=https://sricor.github.io/>Paper</a></div></footer></body></html>