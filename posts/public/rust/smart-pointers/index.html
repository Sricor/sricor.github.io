<!doctype html><html class="not-ready lg:text-base" style=--bg:#faf8f1 lang=zh-cn><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Rust Smart Pointers - Paper</title>
<meta name=theme-color><meta name=description content="Box<T> have single owners Box<T> allow to store data on the heap. Box<T> is a pointer, point to data on the heap. When a box goes out of scope, it will be deallocated (both for the heap and stack). Implementing the Deref trait allows to customize the behavior of the dereference operator *. Implementing the Drop trait, Rust automatically called drop when instances went out of scope. Not allowed to explicitly call drop."><meta name=author content="Sricor"><link rel="preload stylesheet" as=style href=/main.min.css><link rel=preload as=image href=/theme.svg><link rel=preload as=image href=/twitter.svg><link rel=preload as=image href=/github.svg><script defer src=/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css integrity=sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js integrity=sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",()=>renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1}))</script><link rel=icon href=/favicon.ico><link rel=apple-touch-icon href=/apple-touch-icon.png><meta name=generator content="Hugo 0.125.1"><meta itemprop=name content="Rust Smart Pointers"><meta itemprop=description content="Box<T> have single owners Box<T> allow to store data on the heap. Box<T> is a pointer, point to data on the heap. When a box goes out of scope, it will be deallocated (both for the heap and stack). Implementing the Deref trait allows to customize the behavior of the dereference operator *. Implementing the Drop trait, Rust automatically called drop when instances went out of scope. Not allowed to explicitly call drop."><meta itemprop=datePublished content="2023-12-12T00:00:00+00:00"><meta itemprop=dateModified content="2023-12-12T00:00:00+00:00"><meta itemprop=wordCount content="2763"><meta itemprop=keywords content="Rust,Programming"><meta property="og:url" content="/posts/public/rust/smart-pointers/"><meta property="og:site_name" content="Paper"><meta property="og:title" content="Rust Smart Pointers"><meta property="og:description" content="Box&amp;lt;T&amp;gt; have single owners Box&amp;lt;T&amp;gt; allow to store data on the heap. Box&amp;lt;T&amp;gt; is a pointer, point to data on the heap. When a box goes out of scope, it will be deallocated (both for the heap and stack). Implementing the Deref trait allows to customize the behavior of the dereference operator *. Implementing the Drop trait, Rust automatically called drop when instances went out of scope. Not allowed to explicitly call drop."><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-12T00:00:00+00:00"><meta property="article:modified_time" content="2023-12-12T00:00:00+00:00"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Programming"><meta name=twitter:card content="summary"><meta name=twitter:title content="Rust Smart Pointers"><meta name=twitter:description content="Box<T> have single owners Box<T> allow to store data on the heap. Box<T> is a pointer, point to data on the heap. When a box goes out of scope, it will be deallocated (both for the heap and stack). Implementing the Deref trait allows to customize the behavior of the dereference operator *. Implementing the Drop trait, Rust automatically called drop when instances went out of scope. Not allowed to explicitly call drop."><link rel=canonical href=/posts/public/rust/smart-pointers/></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-3xl px-8 lg:justify-center"><div class="relative z-50 mr-auto flex items-center"><a class="-translate-x-[1px] -translate-y-[1px] text-2xl font-semibold" href=/>Paper</a><div class="btn-dark text-[0] ml-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.svg)_left_center/cover_no-repeat] dark:invert dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 -mr-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#faf8f1".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"><nav class="mt-12 flex justify-center space-x-10 dark:invert lg:ml-12 lg:mt-0 lg:items-center lg:space-x-6"><a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./twitter.svg) href=https://twitter.com/josricor target=_blank rel=me>twitter
</a><a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./github.svg) href=https://github.com/Sricor target=_blank rel=me>github</a></nav></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-3xl px-8 pb-16 pt-12 dark:prose-invert"><article><header class=mb-16><h1 class="!my-0 pb-2.5">Rust Smart Pointers</h1><div class="text-sm antialiased opacity-60"><time>Dec 12, 2023</time>
<span class=mx-1>&#183;</span>
<span>Sricor</span></div></header><section><blockquote><ul><li><code>Box&lt;T></code> have single owners</li><li><code>Box&lt;T></code> allow to store data on the heap.</li><li><code>Box&lt;T></code> is a pointer, point to data on the heap.</li><li>When a box goes out of scope, it will be deallocated (both for the heap and stack).</li></ul></blockquote><blockquote><ul><li>Implementing the <code>Deref</code> trait allows to customize the behavior of the dereference operator <code>*</code>.</li></ul></blockquote><blockquote><ul><li>Implementing the <code>Drop</code> trait, Rust automatically called <code>drop</code> when instances went out of scope.</li><li>Not allowed to explicitly call <code>drop</code>.</li><li>Can drop a value early with <code>std::mem::drop</code>.</li><li>Variables are dropped in the reverse order of their creation.</li></ul></blockquote><blockquote><ul><li><code>Rc&lt;T></code> allows a single value to have multiple owners.</li><li><code>Rc&lt;T></code> allows only immutable borrows checked at compile time.</li><li><code>Rc&lt;T></code> only gives immutable access to that data.</li><li><code>Rc&lt;T></code> only for use in single-threaded scenarios.</li><li><code>Rc::clone</code> does not make a deep copy, it does not take much time.</li><li><code>Drop</code> trait decreases the reference count automatically when an <code>Rc&lt;T></code> value goes out of scope</li></ul></blockquote><blockquote><ul><li><code>RefCell&lt;T></code> have single owners.</li><li><code>RefCell&lt;T></code> allows immutable or mutable borrows checked at runtime.</li><li><code>RefCell&lt;T></code> will panic at runtime when try to violate borrow rules.</li><li><code>RefCell&lt;T></code> only for use in single-threaded scenarios.</li></ul></blockquote><h3 id=1-using-boxt-to-point-to-data-on-the-heaphttpsdocrust-langorgstablebookch15-01-boxhtml><a href=https://doc.rust-lang.org/stable/book/ch15-01-box.html>1. Using Box to Point to Data on the Heap</a></h3><p>Boxes allow to store data on the heap rather than the stack.</p><p>Will use them most often in these situations:</p><ul><li>have a type whose size can&rsquo;t be known at compile time</li><li>have a large amount of data and want to transfer ownership but ensure the data won&rsquo;t be copied</li><li>want to own a value and care only that it&rsquo;s a type that implements a particular trait rather than being of a specific type</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> b <span style=color:#f92672>=</span> Box::new(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;b = </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, b);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Define the variable <code>b</code> to have the value of a <code>Box</code> that points to the value <code>5</code>, which is allocated on the heap. When a box goes out of scope, as <code>b</code> does at the end of <code>main</code>, it will be deallocated. The deallocation happens both for the box (stored on the stack) and the data it points to (stored on the heap).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// This code does not compile
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>List</span> {
</span></span><span style=display:flex><span>    Cons(<span style=color:#66d9ef>i32</span>, List),
</span></span><span style=display:flex><span>    Nil,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> <span style=color:#66d9ef>crate</span>::List::{Cons, Nil};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> list <span style=color:#f92672>=</span> Cons(<span style=color:#ae81ff>1</span>, Cons(<span style=color:#ae81ff>2</span>, Cons(<span style=color:#ae81ff>3</span>, Nil)));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This code does not compile, Because Rust can’t figure out how much space to allocate for recursively defined types.</p><p><img src=https://doc.rust-lang.org/stable/book/img/trpl15-01.svg alt="An infinite List consisting of infinite Cons variants"></p><p>Put a <code>Box&lt;T></code> inside the <code>Cons</code> variant instead of another <code>List</code> value directly. The <code>Box&lt;T></code> will point to the next <code>List</code> value that will be on the heap rather than inside the <code>Cons</code> variant.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>List</span> {
</span></span><span style=display:flex><span>    Cons(<span style=color:#66d9ef>i32</span>, Box<span style=color:#f92672>&lt;</span>List<span style=color:#f92672>&gt;</span>),
</span></span><span style=display:flex><span>    Nil,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> <span style=color:#66d9ef>crate</span>::List::{Cons, Nil};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> list <span style=color:#f92672>=</span> Cons(<span style=color:#ae81ff>1</span>, Box::new(Cons(<span style=color:#ae81ff>2</span>, Box::new(Cons(<span style=color:#ae81ff>3</span>, Box::new(Nil))))));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Because a <code>Box&lt;T></code> is a pointer, Rust always knows how much space a <code>Box&lt;T></code> needs: a pointer’s size doesn’t change based on the amount of data it’s pointing to.
We now know that any <code>List</code> value will take up the size of an <code>i32</code> plus the size of a box’s pointer data. By using a box broken the infinite, recursive chain, so the compiler can figure out the size it needs to store a <code>List</code> value.</p><p><img src=https://doc.rust-lang.org/stable/book/img/trpl15-02.svg alt="A List that is not infinitely sized because Cons holds a Box"></p><p>Boxes provide only the indirection and heap allocation,  they don’t have any other special capabilities.</p><p>The <code>Box&lt;T></code> type is a smart pointer because it implements the <code>Deref</code> trait, which allows <code>Box&lt;T></code> values to be treated like references. When a <code>Box&lt;T></code> value goes out of scope, the heap data that the box is pointing to is cleaned up as well because of the <code>Drop</code> trait implementation.</p><h3 id=2-treating-smart-pointers-like-regular-references-with-thedereftraithttpsdocrust-langorgstablebookch15-02-derefhtml><a href=https://doc.rust-lang.org/stable/book/ch15-02-deref.html>2. Treating Smart Pointers Like Regular References with the <code>Deref</code> Trait</a></h3><p>Implementing the <code>Deref</code> trait allows to customize the behavior of the <em>dereference operator</em> <code>*</code></p><p>By implementing <code>Deref</code> in such a way that a smart pointer can be treated like a regular reference, you can write code that operates on references and use that code with smart pointers too.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// This code does not compile
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Using Box&lt;T&gt; Like a Reference
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>MyBox</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>(T);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> MyBox<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>(x: <span style=color:#a6e22e>T</span>) -&gt; <span style=color:#a6e22e>MyBox</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        MyBox(x)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> y <span style=color:#f92672>=</span> MyBox::new(x);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    assert_eq!(<span style=color:#ae81ff>5</span>, x);
</span></span><span style=display:flex><span>    assert_eq!(<span style=color:#ae81ff>5</span>, <span style=color:#f92672>*</span>y);  <span style=color:#75715e>// error: type `MyBox&lt;{integer}&gt;` cannot be dereferenced
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p><code>MyBox&lt;T></code> type can’t be dereferenced because we haven’t implemented that ability on our type. To enable dereferencing with the <code>*</code> operator, we implement the <code>Deref</code> trait.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::ops::Deref;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> Deref <span style=color:#66d9ef>for</span> MyBox<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Target</span> <span style=color:#f92672>=</span> T;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>deref</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Self</span>::Target {
</span></span><span style=display:flex><span>        <span style=color:#f92672>&amp;</span>self.<span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Without the <code>Deref</code> trait, the compiler can only dereference <code>&</code> references. The <code>deref</code> method gives the compiler the ability to take a value of any type that implements <code>Deref</code> and call the <code>deref</code> method to get a <code>&</code> reference that it knows how to dereference.</p><p>When we entered <code>*y</code>, behind the scenes Rust actually ran this code <code>*(y.deref())</code>.
The <code>*</code> operator is replaced with a call to the <code>deref</code> method and then a call to the <code>*</code> operator just once, each time we use a <code>*</code> in our code. Because the substitution of the <code>*</code> operator does not recurse infinitely.</p><h4 id=implicit-deref-coercions-with-functions-and-methods>Implicit Deref Coercions with Functions and Methods</h4><p><em>Deref coercion</em> converts a reference to a type that implements the <code>Deref</code> trait into a reference to another type. For example, deref coercion can convert <code>&amp;String</code> to <code>&amp;str</code> because <code>String</code> implements the <code>Deref</code> trait such that it returns <code>&amp;str</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>hello</span>(name: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;Hello, </span><span style=color:#e6db74>{name}</span><span style=color:#e6db74>!&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> m <span style=color:#f92672>=</span> MyBox::new(String::from(<span style=color:#e6db74>&#34;Rust&#34;</span>));
</span></span><span style=display:flex><span>    hello(<span style=color:#f92672>&amp;</span>m);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// If Rust didn’t implement deref coercion
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// hello(&amp;(*m)[..]);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>When the <code>Deref</code> trait is defined for the types involved, Rust will analyze the types and use <code>Deref::deref</code> as many times as necessary to get a reference to match the parameter’s type. The number of times that <code>Deref::deref</code> needs to be inserted is resolved at compile time, so there is no runtime penalty for taking advantage of deref coercion.</p><h4 id=how-deref-coercion-interacts-with-mutability>How Deref Coercion Interacts with Mutability</h4><ul><li>From <code>&amp;T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U></code></li><li>From <code>&amp;mut T</code> to <code>&amp;mut U</code> when <code>T: DerefMut&lt;Target=U></code></li><li>From <code>&amp;mut T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U></code></li></ul><h3 id=3-running-code-on-cleanup-with-the-drop-traithttpsdocrust-langorgstablebookch15-03-drophtml><a href=https://doc.rust-lang.org/stable/book/ch15-03-drop.html>3. Running Code on Cleanup with the Drop Trait</a></h3><p>Specify the code to run when a value goes out of scope by implementing the <code>Drop</code> trait. The <code>Drop</code> trait requires you to implement one method named <code>drop</code> that takes a mutable reference to <code>self</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>CustomSmartPointer</span> {
</span></span><span style=display:flex><span>    data: String,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Drop <span style=color:#66d9ef>for</span> CustomSmartPointer {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>drop</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) {
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;Dropping CustomSmartPointer with data `</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>`!&#34;</span>, self.data);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> c <span style=color:#f92672>=</span> CustomSmartPointer {
</span></span><span style=display:flex><span>        data: String::from(<span style=color:#e6db74>&#34;my stuff&#34;</span>),
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> d <span style=color:#f92672>=</span> CustomSmartPointer {
</span></span><span style=display:flex><span>        data: String::from(<span style=color:#e6db74>&#34;other stuff&#34;</span>),
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;CustomSmartPointers created.&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Rust doesn’t call <code>drop</code> explicitly because Rust would still automatically call <code>drop</code> on the value at the end of <code>main</code>. This would cause a <em>double free</em> error because Rust would be trying to clean up the same value twice.</p><h4 id=dropping-a-value-early-with-stdmemdrop>Dropping a Value Early with std::mem::drop</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> c <span style=color:#f92672>=</span> CustomSmartPointer {
</span></span><span style=display:flex><span>        data: String::from(<span style=color:#e6db74>&#34;some data&#34;</span>),
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;CustomSmartPointer created.&#34;</span>);
</span></span><span style=display:flex><span>    drop(c);
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;CustomSmartPointer dropped before the end of main.&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=4-rct-the-reference-counted-smart-pointerhttpsdocrust-langorgstablebookch15-04-rchtml><a href=https://doc.rust-lang.org/stable/book/ch15-04-rc.html>4. Rc, the Reference Counted Smart Pointer</a></h3><p>Enable multiple ownership explicitly by using the Rust type <code>Rc&lt;T></code>, which is an abbreviation for <em>reference counting</em>. The <code>Rc&lt;T></code> type keeps track of the number of references to a value to determine whether or not the value is still in use. If there are zero references to a value, the value can be cleaned up without any references becoming invalid.</p><p>We use the <code>Rc&lt;T></code> type when we want to allocate some data on the heap for multiple parts of our program to read and we can’t determine at compile time which part will finish using the data last. If we knew which part would finish last, we could just make that part the data’s owner, and the normal ownership rules enforced at compile time would take effect.</p><p> <code>Rc&lt;T></code> is only for use in single-threaded scenarios.</p><h4 id=using-rct-to-share-data>Using Rc to Share Data</h4><p><img src=https://doc.rust-lang.org/stable/book/img/trpl15-03.svg alt="Two lists, b and c, sharing ownership of a third list, a"></p><p>Trying to implement this scenario using our definition of <code>List</code> with <code>Box&lt;T></code> won’t work</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// This code does not compile
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>List</span> {
</span></span><span style=display:flex><span>    Cons(<span style=color:#66d9ef>i32</span>, Box<span style=color:#f92672>&lt;</span>List<span style=color:#f92672>&gt;</span>),
</span></span><span style=display:flex><span>    Nil,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> <span style=color:#66d9ef>crate</span>::List::{Cons, Nil};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> Cons(<span style=color:#ae81ff>5</span>, Box::new(Cons(<span style=color:#ae81ff>10</span>, Box::new(Nil))));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> b <span style=color:#f92672>=</span> Cons(<span style=color:#ae81ff>3</span>, Box::new(a));   <span style=color:#75715e>// error: use of moved value: `a`
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> c <span style=color:#f92672>=</span> Cons(<span style=color:#ae81ff>4</span>, Box::new(a));   <span style=color:#75715e>// error: value used here after move
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>when try to use <code>a</code> again when creating <code>c</code>, not allowed to because <code>a</code> has been moved.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>List</span> {
</span></span><span style=display:flex><span>    Cons(<span style=color:#66d9ef>i32</span>, Rc<span style=color:#f92672>&lt;</span>List<span style=color:#f92672>&gt;</span>),
</span></span><span style=display:flex><span>    Nil,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> <span style=color:#66d9ef>crate</span>::List::{Cons, Nil};
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> std::rc::Rc;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> Rc::new(Cons(<span style=color:#ae81ff>5</span>, Rc::new(Cons(<span style=color:#ae81ff>10</span>, Rc::new(Nil)))));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> b <span style=color:#f92672>=</span> Cons(<span style=color:#ae81ff>3</span>, Rc::clone(<span style=color:#f92672>&amp;</span>a));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> c <span style=color:#f92672>=</span> Cons(<span style=color:#ae81ff>4</span>, Rc::clone(<span style=color:#f92672>&amp;</span>a));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Change definition of <code>List</code> to use <code>Rc&lt;T></code> in place of <code>Box&lt;T></code>, Each <code>Cons</code> variant will now hold a value and an <code>Rc&lt;T></code> pointing to a <code>List</code>. When create <code>b</code>, instead of taking ownership of <code>a</code>, it will clone the <code>Rc&lt;List></code> that <code>a</code> is holding, thereby increasing the number of references from one to two and letting <code>a</code> and <code>b</code> share ownership of the data in that <code>Rc&lt;List></code>. it will also clone <code>a</code> when creating <code>c</code>, increasing the number of references from two to three. Every time call <code>Rc::clone</code>, the reference count to the data within the <code>Rc&lt;List></code> will increase, and the data won’t be cleaned up unless there are <strong>zero references</strong> to it.</p><p>Could have called <code>a.clone()</code> rather than <code>Rc::clone(&amp;a)</code>, but Rust’s convention is to use <code>Rc::clone</code> in this case. The implementation of <strong><code>Rc::clone</code> doesn’t make a deep copy</strong> of all the data like most types’ implementations of <code>clone</code> do. The call to <code>Rc::clone</code> only increments the reference count, which doesn’t take much time. Deep copies of data can take a lot of time. By using <code>Rc::clone</code> for reference counting, we can visually distinguish between the deep-copy kinds of clones and the kinds of clones that increase the reference count.</p><h4 id=cloning-anrctincreases-the-reference-count>Cloning an <code>Rc&lt;T></code> Increases the Reference Count</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> Rc::new(Cons(<span style=color:#ae81ff>5</span>, Rc::new(Cons(<span style=color:#ae81ff>10</span>, Rc::new(Nil)))));
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;count after creating a = </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, Rc::strong_count(<span style=color:#f92672>&amp;</span>a));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> b <span style=color:#f92672>=</span> Cons(<span style=color:#ae81ff>3</span>, Rc::clone(<span style=color:#f92672>&amp;</span>a));
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;count after creating b = </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, Rc::strong_count(<span style=color:#f92672>&amp;</span>a));
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> c <span style=color:#f92672>=</span> Cons(<span style=color:#ae81ff>4</span>, Rc::clone(<span style=color:#f92672>&amp;</span>a));
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;count after creating c = </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, Rc::strong_count(<span style=color:#f92672>&amp;</span>a));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;count after c goes out of scope = </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, Rc::strong_count(<span style=color:#f92672>&amp;</span>a));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>At each point in the program where the reference count changes, we print the reference count, which get by calling the <code>Rc::strong_count</code> function.</p><p>This code prints the following:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>count after creating a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>count after creating b <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>count after creating c <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>count after c goes out of scope <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>
</span></span></code></pre></div><p>The <code>Drop</code> trait decreases the reference count automatically when an <code>Rc&lt;T></code> value goes out of scope. Using <code>Rc&lt;T></code> allows a single value to have multiple owners, and the count ensures that the value remains valid as long as any of the owners still exist.</p><h3 id=5-refcellt-and-the-interior-mutability-patternhttpsdocrust-langorgstablebookch15-05-interior-mutabilityhtml><a href=https://doc.rust-lang.org/stable/book/ch15-05-interior-mutability.html>5. RefCell and the Interior Mutability Pattern</a></h3><p><em>Interior mutability</em> is a design pattern in Rust that allows you to mutate data even when there are immutable references to that data, To mutate data, the pattern uses <code>unsafe</code> code inside a data structure to bend Rust’s usual rules that govern mutation and borrowing. Unsafe code indicates to the compiler that we’re checking the rules manually instead of relying on the compiler to check them for us</p><h4 id=enforcing-borrowing-rules-at-runtime-with-refcellt>Enforcing Borrowing Rules at Runtime with RefCell</h4><p>The <code>RefCell&lt;T></code> type represents single ownership over the data it holds</p><p>With references and <code>Box&lt;T></code>, the borrowing rules’ invariants are enforced <strong>at compile time</strong>. With <code>RefCell&lt;T></code>, these invariants are enforced <strong>at runtime.</strong> With references, if you break these rules, you’ll get a compiler error. With <code>RefCell&lt;T></code>, if you break these rules, your program will panic and exit.</p><p>Because <code>RefCell&lt;T></code> allows mutable borrows checked at runtime, you can mutate the value inside the <code>RefCell&lt;T></code> even when the <code>RefCell&lt;T></code> is immutable.</p><p><code>RefCell&lt;T></code> is only for use in single-threaded scenarios and will give you a compile-time error if you try using it in a multithreaded context.</p><p>Mutating the value inside an immutable value is the <em>interior mutability</em> pattern.</p><h4 id=interior-mutability-a-mutable-borrow-to-an-immutable-value>Interior Mutability: A Mutable Borrow to an Immutable Value</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// This code does not compile
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> y <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> x;  <span style=color:#75715e>// error: cannot borrow as mutable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>Using <code>RefCell&lt;T></code> is one way to get the ability to have interior mutability, but <code>RefCell&lt;T></code> doesn’t get around the borrowing rules completely: the borrow checker in the compiler allows this interior mutability, and the borrowing rules are checked at runtime instead. If violate the rules, will get a <code>panic!</code> instead of a compiler error.</p><p>Exaple:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>trait</span> Messenger {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>send</span>(<span style=color:#f92672>&amp;</span>self, msg: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>LimitTracker</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span>, T: <span style=color:#a6e22e>Messenger</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    messenger: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;a</span> <span style=color:#a6e22e>T</span>,
</span></span><span style=display:flex><span>    value: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>    max: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span>, T<span style=color:#f92672>&gt;</span> LimitTracker<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span>, T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>    T: <span style=color:#a6e22e>Messenger</span>,
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>(messenger: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;a</span> <span style=color:#a6e22e>T</span>, max: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#a6e22e>LimitTracker</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span>, T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        LimitTracker {
</span></span><span style=display:flex><span>            messenger,
</span></span><span style=display:flex><span>            value: <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>            max,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>set_value</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, value: <span style=color:#66d9ef>usize</span>) {
</span></span><span style=display:flex><span>        self.value <span style=color:#f92672>=</span> value;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> percentage_of_max <span style=color:#f92672>=</span> self.value <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f64</span> <span style=color:#f92672>/</span> self.max <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f64</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> percentage_of_max <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>1.0</span> {
</span></span><span style=display:flex><span>            self.messenger.send(<span style=color:#e6db74>&#34;Error: You are over your quota!&#34;</span>);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> percentage_of_max <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0.9</span> {
</span></span><span style=display:flex><span>            self.messenger
</span></span><span style=display:flex><span>                .send(<span style=color:#e6db74>&#34;Urgent warning: You&#39;ve used up over 90% of your quota!&#34;</span>);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> percentage_of_max <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0.75</span> {
</span></span><span style=display:flex><span>            self.messenger
</span></span><span style=display:flex><span>                .send(<span style=color:#e6db74>&#34;Warning: You&#39;ve used up over 75% of your quota!&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// This code does not compile
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[cfg(test)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> tests {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>use</span> <span style=color:#66d9ef>super</span>::<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>MockMessenger</span> {
</span></span><span style=display:flex><span>        sent_messages: Vec<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>impl</span> MockMessenger {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>() -&gt; <span style=color:#a6e22e>MockMessenger</span> {
</span></span><span style=display:flex><span>            MockMessenger {
</span></span><span style=display:flex><span>                sent_messages: <span style=color:#a6e22e>vec</span><span style=color:#f92672>!</span>[],
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>impl</span> Messenger <span style=color:#66d9ef>for</span> MockMessenger {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>send</span>(<span style=color:#f92672>&amp;</span>self, message: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) {
</span></span><span style=display:flex><span>            self.sent_messages.push(String::from(message)); <span style=color:#75715e>// error: `self` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>it_sends_an_over_75_percent_warning_message</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> mock_messenger <span style=color:#f92672>=</span> MockMessenger::new();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> limit_tracker <span style=color:#f92672>=</span> LimitTracker::new(<span style=color:#f92672>&amp;</span>mock_messenger, <span style=color:#ae81ff>100</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        limit_tracker.set_value(<span style=color:#ae81ff>80</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        assert_eq!(mock_messenger.sent_messages.len(), <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Can’t modify the <code>MockMessenger</code> to keep track of the messages, because the <code>send</code> method takes an immutable reference to <code>self</code>. Also can’t use <code>&amp;mut self</code> instead, because then the signature of <code>send</code> wouldn’t match the signature in the <code>Messenger</code> trait definition.</p><p>Using <code>RefCell&lt;T></code> to mutate an inner value while the outer value is considered immutable.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[cfg(test)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> tests {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>use</span> <span style=color:#66d9ef>super</span>::<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>use</span> std::cell::RefCell;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>MockMessenger</span> {
</span></span><span style=display:flex><span>        sent_messages: <span style=color:#a6e22e>RefCell</span><span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;&gt;</span>,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>impl</span> MockMessenger {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>() -&gt; <span style=color:#a6e22e>MockMessenger</span> {
</span></span><span style=display:flex><span>            MockMessenger {
</span></span><span style=display:flex><span>                sent_messages: <span style=color:#a6e22e>RefCell</span>::new(vec![]),
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>impl</span> Messenger <span style=color:#66d9ef>for</span> MockMessenger {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>send</span>(<span style=color:#f92672>&amp;</span>self, message: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) {
</span></span><span style=display:flex><span>            self.sent_messages.borrow_mut().push(String::from(message));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>it_sends_an_over_75_percent_warning_message</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// --snip--
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        assert_eq!(mock_messenger.sent_messages.borrow().len(), <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h4 id=keeping-track-of-borrows-at-runtime-with-refcellt>Keeping Track of Borrows at Runtime with RefCell</h4><p>When creating immutable and mutable references, use the <code>&</code> and <code>&amp;mut</code> syntax, respectively. With <code>RefCell&lt;T></code>, use the <code>borrow</code> and <code>borrow_mut</code> methods, which are part of the safe API that belongs to <code>RefCell&lt;T></code>. The <code>borrow</code> method returns the smart pointer type <code>Ref&lt;T></code>, and <code>borrow_mut</code> returns the smart pointer type <code>RefMut&lt;T></code>. Both types implement <code>Deref</code>, so can treat them like regular references.</p><p>The <code>RefCell&lt;T></code> keeps track of how many <code>Ref&lt;T></code> and <code>RefMut&lt;T></code> smart pointers are currently active. Every time call <code>borrow</code>, the <code>RefCell&lt;T></code> increases its count of how many immutable borrows are active. When a <code>Ref&lt;T></code> value goes out of scope, the count of immutable borrows goes down by one. Just like the compile-time borrowing rules, <code>RefCell&lt;T></code> lets us have many immutable borrows or one mutable borrow at any point in time.</p><p>If we try to violate these rules, rather than getting a compiler error as we would with references, the implementation of <code>RefCell&lt;T></code> will panic at runtime.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// This code panics
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>impl</span> Messenger <span style=color:#66d9ef>for</span> MockMessenger {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>send</span>(<span style=color:#f92672>&amp;</span>self, message: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> one_borrow <span style=color:#f92672>=</span> self.sent_messages.borrow_mut();
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> two_borrow <span style=color:#f92672>=</span> self.sent_messages.borrow_mut();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		one_borrow.push(String::from(message));
</span></span><span style=display:flex><span>		two_borrow.push(String::from(message)); <span style=color:#75715e>// error: already borrowed: BorrowMutError
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt>Having Multiple Owners of Mutable Data by Combining Rc and RefCell</h4><p>A common way to use RefCell is in combination with Rc. Rc lets you have multiple owners of some data, but it only gives immutable access to that data.</p><p>Using <code>Rc&lt;RefCell&lt;i32>></code> to create a List that we can mutate.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>List</span> {
</span></span><span style=display:flex><span>    Cons(Rc<span style=color:#f92672>&lt;</span>RefCell<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;&gt;</span>, Rc<span style=color:#f92672>&lt;</span>List<span style=color:#f92672>&gt;</span>),
</span></span><span style=display:flex><span>    Nil,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> <span style=color:#66d9ef>crate</span>::List::{Cons, Nil};
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> std::cell::RefCell;
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> std::rc::Rc;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> value <span style=color:#f92672>=</span> Rc::new(RefCell::new(<span style=color:#ae81ff>5</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> Rc::new(Cons(Rc::clone(<span style=color:#f92672>&amp;</span>value), Rc::new(Nil)));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> b <span style=color:#f92672>=</span> Cons(Rc::new(RefCell::new(<span style=color:#ae81ff>3</span>)), Rc::clone(<span style=color:#f92672>&amp;</span>a));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> c <span style=color:#f92672>=</span> Cons(Rc::new(RefCell::new(<span style=color:#ae81ff>4</span>)), Rc::clone(<span style=color:#f92672>&amp;</span>a));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>value.borrow_mut() <span style=color:#f92672>+=</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;a after = </span><span style=color:#e6db74>{:?}</span><span style=color:#e6db74>&#34;</span>, a);
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;b after = </span><span style=color:#e6db74>{:?}</span><span style=color:#e6db74>&#34;</span>, b);
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;c after = </span><span style=color:#e6db74>{:?}</span><span style=color:#e6db74>&#34;</span>, c);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This code prints the following:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>a after <span style=color:#f92672>=</span> Cons(RefCell { value: <span style=color:#ae81ff>15</span> }, Nil)
</span></span><span style=display:flex><span>b after <span style=color:#f92672>=</span> Cons(RefCell { value: <span style=color:#ae81ff>3</span> }, Cons(RefCell { value: <span style=color:#ae81ff>15</span> }, Nil))
</span></span><span style=display:flex><span>c after <span style=color:#f92672>=</span> Cons(RefCell { value: <span style=color:#ae81ff>4</span> }, Cons(RefCell { value: <span style=color:#ae81ff>15</span> }, Nil))
</span></span></code></pre></div><p>Have an outwardly immutable List value. But can use the methods on <code>RefCell&lt;T></code> that provide access to its interior mutability so can modify data.The runtime checks of the borrowing rules protect us from data races, and it’s sometimes worth trading a bit of speed for this flexibility in our data structures.</p></section><footer class="mt-12 flex flex-wrap"><a class="mb-1.5 mr-1.5 rounded-lg bg-black/[3%] px-5 py-1.5 no-underline dark:bg-white/[8%]" href=/tags/rust>Rust</a>
<a class="mb-1.5 mr-1.5 rounded-lg bg-black/[3%] px-5 py-1.5 no-underline dark:bg-white/[8%]" href=/tags/programming>Programming</a></footer></article></main><footer class="opaco mx-auto flex h-[4.5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"><div class=mr-auto>&copy; 2024
<a class=link href=/>Paper</a></div></footer></body></html>